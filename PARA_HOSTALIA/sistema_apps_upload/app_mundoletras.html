<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#1e3a8a">
    <meta name="description" content="Mundo Letras - Juego de sopa de letras con m√°s de 1000 niveles">
    
    <!-- PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Mundo Letras">
    
    <title>Mundo Letras - Sopa de Letras</title>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        input, textarea {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #1e40af 0%, #1e3a8a 100%);
            color: white;
            height: 100vh;
            overflow: hidden;
        }
        
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none !important;
            flex-direction: column;
        }
        
        .screen.active {
            display: flex !important;
        }
        
        /* Login Screen */
        .login-screen {
            align-items: center;
            justify-content: center;
            padding: 2rem;
        }
        
        .login-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 400px;
            width: 100%;
            text-align: center;
        }
        
        .logo {
            font-size: 4rem;
            margin-bottom: 1rem;
        }
        
        .title {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.8;
            margin-bottom: 2rem;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            min-height: 44px;
            margin: 0.5rem;
            width: calc(100% - 1rem);
        }
        
        .btn-primary {
            background-color: #3b82f6;
            color: white;
            border-left: 4px solid #1e40af;
        }
        
        .btn-primary:hover {
            background-color: #1e40af;
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.2);
            color: white;
            border-left: 4px solid rgba(255, 255, 255, 0.3);
        }
        
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }
        
        /* Game Screen */
        .game-screen {
            padding: 1rem;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }
        
        /* Layout responsivo para el juego */
        @media (max-width: 480px) {
            .game-screen {
                padding: 0.5rem;
            }
        }
        
        .game-hud {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 1rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        
        .hud-user-line {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
        }
        
        .game-logo {
            height: 60px;
            width: auto;
            object-fit: contain;
        }
        
        .title-logo {
            height: 150px;
            width: auto;
            object-fit: contain;
            margin: 1.5rem 0;
        }
        
        .hud-stats-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 0.5rem;
        }
        
        .hud-item {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .hud-value {
            font-weight: bold;
            color: #fbbf24;
        }
        
        .user-info {
            flex-direction: column;
            align-items: flex-start;
            gap: 0.1rem;
            min-width: 80px;
        }
        
        .user-info #user-icon {
            font-size: 1.2rem;
        }
        
        .user-info #user-name {
            font-weight: bold;
            font-size: 0.9rem;
            color: white;
        }
        
        .user-info #user-status {
            font-size: 0.7rem;
            padding: 0.1rem 0.4rem;
            border-radius: 0.3rem;
            font-weight: 600;
        }
        
        .user-status-guest {
            background-color: rgba(156, 163, 175, 0.3);
            color: #d1d5db;
        }
        
        .user-status-logged {
            background-color: rgba(34, 197, 94, 0.3);
            color: #86efac;
        }
        
        .game-grid {
            display: grid;
            gap: 2px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 0.5rem;
            padding: 0.5rem;
            max-width: 90vw;
            max-height: 90vh;
            margin: 0 auto 1rem;
            grid-template-columns: repeat(6, 1fr);
            aspect-ratio: 1;
            width: 100%;
        }
        
        /* Ajustes responsivos para diferentes tama√±os */
        @media (max-width: 480px) {
            .game-grid {
                gap: 1px;
                padding: 0.15rem;
                max-width: 95vw;
                max-height: 60vh;
            }
            
            /* En m√≥vil, reducir drasticamente el espacio de las palabras */
            .words-list {
                max-height: 25vh;
                overflow-y: auto;
                font-size: 0.8rem;
                padding: 0.4rem;
                gap: 0.3rem;
                margin: 0.5rem 0;
            }
            
            .game-hud {
                padding: 0.15rem;
                gap: 0.15rem;
                margin-bottom: 0.15rem;
            }
            
            .hud-item {
                font-size: 0.7rem;
                padding: 0.15rem 0.3rem;
            }
            
            .hud-stats-line {
                flex-wrap: wrap;
                gap: 0.15rem;
            }
            
            /* Reducir drasticamente espacio en botones inferiores */
            .game-controls {
                padding: 0.15rem;
                gap: 0.1rem;
                margin-top: 0.15rem;
            }
            
            /* En m√≥vil, mostrar solo iconos en los botones */
            .game-controls .btn {
                font-size: 0;
                padding: 0.3rem;
                min-width: 36px;
                min-height: 36px;
                display: flex;
                align-items: center;
                justify-content: center;
                flex: 1;
                max-width: 60px;
            }
            
            .game-controls .btn::before {
                font-size: 1.2rem;
                content: attr(data-icon);
            }
            
            .btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.75rem;
                margin: 0;
            }
            
            /* Reducir espacio general del layout */
            .game-screen {
                padding: 0.25rem;
                gap: 0.25rem;
            }
        }
        
        @media (min-width: 481px) and (max-width: 768px) {
            .game-grid {
                gap: 1.5px;
                padding: 0.4rem;
                max-width: 85vw;
                max-height: 60vh;
            }
            
            .words-list {
                max-height: 30vh;
                padding: 0.5rem;
            }
            
            .game-controls {
                padding: 0.75rem;
                gap: 0.75rem;
            }
            
            /* En pantallas m√°s grandes, mostrar texto normal */
            .game-controls .btn {
                font-size: 0.75rem;
                padding: 0.4rem 0.6rem;
                min-width: auto;
                min-height: auto;
            }
            
            .game-controls .btn::before {
                display: none;
            }
        }
        
        @media (min-width: 769px) {
            .game-grid {
                gap: 2px;
                padding: 0.5rem;
                max-width: 80vw;
                max-height: 75vh;
            }
            
            .words-list {
                max-height: 40vh;
            }
        }
        
        .grid-cell {
            aspect-ratio: 1;
            background-color: rgba(255, 255, 255, 0.9);
            color: #1e40af;
            border: 2px solid transparent;
            border-radius: 0.25rem;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: clamp(0.8rem, 2.5vw, 1.2rem);
            cursor: pointer;
            transition: all 0.2s ease;
            min-height: 30px;
            min-width: 30px;
        }
        
        /* Ajustes responsivos para celdas */
        @media (max-width: 480px) {
            .grid-cell {
                font-size: clamp(0.7rem, 3vw, 1rem);
                border-radius: 0.2rem;
                min-height: 25px;
                min-width: 25px;
            }
        }
        
        @media (min-width: 481px) and (max-width: 768px) {
            .grid-cell {
                font-size: clamp(0.9rem, 2.8vw, 1.1rem);
                min-height: 28px;
                min-width: 28px;
            }
        }
        
        .grid-cell:hover {
            background-color: #e0e7ff;
        }
        
        .grid-cell.selected {
            background-color: #3b82f6;
            color: white;
            border-color: #1e40af;
        }
        
        .grid-cell.found {
            background-color: #10b981;
            color: white;
            border-color: #059669;
        }
        
        .words-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .word-item {
            padding: 0.2rem 0.6rem;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 0.75rem;
            font-weight: 600;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }
        
        .word-item.found {
            background-color: #10b981;
            text-decoration: line-through;
        }
        
        .game-controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            padding: 0.75rem;
        }
        
        .btn-sm {
            padding: 0.5rem 1rem;
            font-size: 0.875rem;
            min-height: 36px;
            width: auto;
        }
        
        /* Responsive */
        @media (max-width: 480px) {
            .game-hud {
                gap: 0.5rem;
                padding: 0.75rem;
            }
            
            .hud-stats-line {
                gap: 0.25rem;
            }
            
            .hud-item {
                font-size: 0.8rem;
            }
            
            .user-info {
                min-width: 70px;
            }
            
            .user-info #user-name {
                font-size: 0.8rem;
            }
            
            .user-info #user-status {
                font-size: 0.6rem;
                padding: 0.05rem 0.3rem;
            }
            
            .grid-cell {
                font-size: 1rem;
                min-height: 36px;
            }
            
            .game-controls {
                flex-direction: row;
                flex-wrap: wrap;
            }
            
            /* En pantallas muy grandes, mantener texto normal */
            .game-controls .btn {
                font-size: 0.75rem;
                padding: 0.4rem 0.6rem;
                min-width: auto;
                min-height: auto;
            }
            
            .game-controls .btn::before {
                display: none;
            }
        }
        
        /* Animaciones de Puntuaci√≥n */
        @keyframes scoreIncrease {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); color: #fbbf24; }
            100% { transform: scale(1); }
        }
        
        @keyframes coinRise {
            0% { 
                transform: translateY(30px) scale(0.7);
                opacity: 0;
            }
            30% { 
                transform: translateY(-15px) scale(1.3);
                opacity: 1;
            }
            60% { 
                transform: translateY(-5px) scale(1.1);
                opacity: 1;
            }
            100% { 
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        @keyframes coinCountUp {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); color: #fbbf24; }
            100% { transform: scale(1); }
        }
        
        @keyframes coinFly {
            0% { 
                transform: translateX(0) translateY(0) scale(1);
                opacity: 1;
            }
            50% { 
                transform: translateX(var(--target-x)) translateY(var(--target-y)) scale(1.2);
                opacity: 0.8;
            }
            100% { 
                transform: translateX(var(--target-x)) translateY(var(--target-y)) scale(0.3);
                opacity: 0;
            }
        }
        
        .flying-coin {
            position: fixed;
            font-size: 1.5rem;
            pointer-events: none;
            z-index: 1000;
            animation: coinFly 1.2s ease-out forwards;
        }
        
        @keyframes levelUp {
            0% { 
                transform: scale(0.8); 
                opacity: 0; 
                filter: blur(10px);
            }
            50% { 
                transform: scale(1.1); 
                opacity: 1; 
                filter: blur(0px);
            }
            100% { 
                transform: scale(1); 
                opacity: 1; 
                filter: blur(0px);
            }
        }
        
        @keyframes wordFound {
            0% { 
                transform: scale(1) rotate(0deg);
                background-color: rgba(255, 255, 255, 0.2);
            }
            50% { 
                transform: scale(1.1) rotate(5deg);
                background-color: #10b981;
            }
            100% { 
                transform: scale(1) rotate(0deg);
                background-color: #10b981;
            }
        }
        
        @keyframes slideInFromBottom {
            0% {
                transform: translateY(100px);
                opacity: 0;
            }
            100% {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        @keyframes fadeInOut {
            0% { opacity: 0; }
            20% { opacity: 1; }
            80% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        /* Clases de animaci√≥n */
        .score-animation {
            animation: scoreIncrease 0.6s ease-in-out;
        }
        
        .coin-animation {
            animation: coinRise 1.2s ease-out;
        }
        
        .coin-count-animation {
            animation: coinCountUp 0.6s ease-in-out;
        }
        
        /* Control de sonido */
        .sound-control {
            cursor: pointer;
            transition: all 0.2s ease;
            opacity: 0.8;
            font-size: 1.2rem;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            position: absolute;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .sound-control:hover {
            opacity: 1;
            transform: scale(1.2);
        }
        
        .sound-control.muted {
            opacity: 0.4;
        }
        
        .word-found-animation {
            animation: wordFound 0.5s ease-in-out;
        }
        
        .level-complete-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeInOut 4s ease-in-out forwards;
        }
        
        .level-complete-content {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            animation: levelUp 0.8s ease-out;
        }
        
        .level-complete-title {
            font-size: 2.5rem;
            color: white;
            margin-bottom: 1rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .level-complete-subtitle {
            font-size: 1.2rem;
            color: #e0e7ff;
            margin-bottom: 1.5rem;
        }
        
        .level-complete-stats {
            display: flex;
            justify-content: space-around;
            margin: 1.5rem 0;
        }
        
        .level-complete-stat {
            text-align: center;
            color: white;
        }
        
        .level-complete-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #fbbf24;
        }
        
        .level-complete-stat-label {
            font-size: 0.9rem;
            color: #e0e7ff;
        }
        
        /* Estilos para el Ranking */
        .ranking-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(5px);
        }
        
        .ranking-content {
            background: linear-gradient(135deg, #1e3a8a 0%, #3730a3 100%);
            border-radius: 1rem;
            padding: 1.5rem;
            max-width: 90vw;
            max-height: 90vh;
            width: 500px;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: levelUp 0.5s ease-out;
        }
        
        .ranking-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            color: white;
        }
        
        .ranking-title {
            font-size: 1.5rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .ranking-close {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            padding: 0.25rem;
            border-radius: 0.25rem;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        
        .ranking-close:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .ranking-list {
            max-height: 60vh;
            overflow-y: auto;
            border-radius: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .ranking-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            transition: background-color 0.2s;
        }
        
        .ranking-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .ranking-item.current-user {
            background: linear-gradient(90deg, #fbbf24, #f59e0b);
            color: #1e40af;
            font-weight: bold;
            box-shadow: 0 2px 10px rgba(251, 191, 36, 0.3);
        }
        
        .ranking-position {
            font-size: 1.1rem;
            font-weight: bold;
            min-width: 40px;
            text-align: center;
        }
        
        .ranking-position.gold {
            color: #fbbf24;
        }
        
        .ranking-position.silver {
            color: #d1d5db;
        }
        
        .ranking-position.bronze {
            color: #cd7f32;
        }
        
        .ranking-player {
            flex: 1;
            margin: 0 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }
        
        .ranking-name {
            font-weight: 600;
            font-size: 1rem;
        }
        
        .ranking-level {
            font-size: 0.85rem;
            opacity: 0.8;
        }
        
        .ranking-stats {
            text-align: right;
            min-width: 80px;
        }
        
        .ranking-score {
            font-size: 1rem;
            font-weight: bold;
        }
        
        .ranking-date {
            font-size: 0.75rem;
            opacity: 0.7;
        }
        
        .ranking-controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .ranking-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }
        
        .ranking-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }
        
        .ranking-loading {
            text-align: center;
            color: white;
            padding: 2rem;
            font-size: 1.1rem;
        }
        
        .ranking-error {
            text-align: center;
            color: #ef4444;
            padding: 2rem;
            font-size: 1rem;
        }
        
        /* Responsive para m√≥vil */
        @media (max-width: 480px) {
            .ranking-content {
                width: 95vw;
                padding: 1rem;
                max-height: 85vh;
            }
            
            .ranking-title {
                font-size: 1.2rem;
            }
            
            .ranking-list {
                max-height: 50vh;
            }
            
            .ranking-item {
                padding: 0.5rem 0.75rem;
                font-size: 0.9rem;
            }
            
            .ranking-player {
                margin: 0 0.5rem;
            }
            
            .ranking-stats {
                min-width: 60px;
            }
        }
        
        /* Loading */
        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top: 2px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Success/Error messages */
        .message {
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
            text-align: center;
        }
        
        .message.success {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid #10b981;
            color: #10b981;
        }
        
        .message.error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #ef4444;
        }
        
        /* Estilos para pesta√±as */
        .tabs-container {
            margin-bottom: 1.5rem;
        }
        
        .tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 0.75rem;
            padding: 0.25rem;
            margin-bottom: 1rem;
        }
        
        .tab-btn {
            flex: 1;
            padding: 0.75rem 1rem;
            border: none;
            background: transparent;
            color: rgba(255, 255, 255, 0.7);
            border-radius: 0.5rem;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab-btn.active {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .tab-btn:hover:not(.active) {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        
        .tab-content {
            position: relative;
        }
        
        .tab-panel {
            display: none;
        }
        
        .tab-panel.active {
            display: block;
        }
        
        /* ===== ESTILOS PARA MEC√ÅNICAS ===== */
        
        /* Mec√°nica de Niebla */
        .grid-cell.fog {
            background-color: rgba(100, 100, 100, 0.8) !important;
            color: #666 !important;
            position: relative;
        }
        
        .grid-cell.fog::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 0.25rem;
            z-index: 1;
        }
        
        /* Mec√°nica de Fantasma */
        .grid-cell.ghost {
            opacity: 0.4 !important;
            animation: ghostPulse 0.8s ease-in-out infinite alternate;
        }
        
        @keyframes ghostPulse {
            0% { 
                opacity: 0.2;
                transform: scale(0.95);
                filter: blur(1px);
            }
            100% { 
                opacity: 0.7;
                transform: scale(1.05);
                filter: blur(0px);
            }
        }
        
        /* Mec√°nica de Timer por Palabra */
        .word-timer {
            font-size: 0.7rem;
            color: #ff6b6b;
            font-weight: bold;
            margin-left: 0.25rem;
        }
        
        .word-item.expired {
            background-color: #ef4444 !important;
            color: white !important;
        }
        
        /* Display de mec√°nicas activas */
        .mechanics-display {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 0.75rem;
            padding: 0.75rem;
            margin-bottom: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
        }
        
        .mechanic-badge {
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-size: 0.8rem;
            font-weight: 600;
            background-color: rgba(59, 130, 246, 0.3);
            color: #93c5fd;
            border: 1px solid rgba(59, 130, 246, 0.5);
        }
        
        .mechanic-badge.fog {
            background-color: rgba(107, 114, 128, 0.3);
            color: #d1d5db;
            border-color: rgba(107, 114, 128, 0.5);
        }
        
        .mechanic-badge.ghost {
            background-color: rgba(147, 51, 234, 0.3);
            color: #c4b5fd;
            border-color: rgba(147, 51, 234, 0.5);
        }
        
        .mechanic-badge.hidden-words {
            background-color: rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            border-color: rgba(239, 68, 68, 0.5);
        }
        
        .mechanic-badge.word-timer {
            background-color: rgba(245, 158, 11, 0.3);
            color: #fcd34d;
            border-color: rgba(245, 158, 11, 0.5);
        }
        
        .mechanic-badge.dynamic-timer {
            background-color: rgba(16, 185, 129, 0.3);
            color: #6ee7b7;
            border-color: rgba(16, 185, 129, 0.5);
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div id="login-screen" class="screen login-screen active">
        <div class="login-card">
            <img src="sistema_apps_api/mundoletras/img/Logo.png" alt="Mundo Letras" class="title-logo">
            <p class="subtitle">Juego de sopa de letras con 1000+ niveles</p>
            
            <div id="login-content">
                <button class="btn btn-primary" onclick="startAsGuest()">
                    üë§ Jugar como Invitado
                </button>
                
                <button class="btn btn-secondary" onclick="showLogin()">
                    üîê Identificarse
                </button>
                
            </div>
            
            <div id="message-container"></div>
        </div>
    </div>
    
    <!-- Game Screen -->
    <div id="game-screen" class="screen game-screen">
        <!-- HUD -->
        <div class="game-hud">
            <!-- Primera l√≠nea: Informaci√≥n del usuario -->
            <div class="hud-user-line">
                <div class="hud-item user-info">
                    <span id="user-icon">üë§</span>
                    <span id="user-name">Invitado</span>
                    <span id="user-status" class="user-status-guest">Invitado</span>
                </div>
                <span id="sound-control" class="sound-control" onclick="toggleSound()" title="Activar/Desactivar sonido">üîä</span>
            </div>
            
            <!-- Segunda l√≠nea: Estad√≠sticas del juego -->
            <div class="hud-stats-line">
                <div class="hud-item">
                    <span>‚ö°</span>
                    <span id="score" class="hud-value">0</span>
                </div>
                <div class="hud-item">
                    <span>üî•</span>
                    <span id="streak" class="hud-value">0</span>
                </div>
                <div class="hud-item">
                    <span>üí∞</span>
                    <span id="coins" class="hud-value">50</span>
                </div>
                <div class="hud-item">
                    <span>üìä</span>
                    <span>Nivel <span id="level" class="hud-value">1</span></span>
                </div>
                <div class="hud-item" id="dynamic-timer-display" style="display: none;">
                    <span>‚è±Ô∏è</span>
                    <span id="dynamic-timer" class="hud-value">120</span>
                </div>
            </div>
        </div>
        
        <!-- Display de Mec√°nicas Activas -->
        <div id="mechanics-display" class="mechanics-display" style="display: none;">
            <!-- Las mec√°nicas se mostrar√°n aqu√≠ din√°micamente -->
        </div>
        
        <!-- Game Grid -->
        <div id="game-grid" class="game-grid">
            <!-- Cells will be generated by JavaScript -->
        </div>
        
        <!-- Words List -->
        <div id="words-list" class="words-list">
            <!-- Words will be generated by JavaScript -->
        </div>
        
        <!-- Game Controls -->
        <div class="game-controls">
            <button class="btn btn-secondary btn-sm" onclick="clearSelection()" data-icon="üö´" title="Limpiar Selecci√≥n">
                üö´ Limpiar Selecci√≥n
            </button>
            <button class="btn btn-secondary btn-sm" onclick="showRanking()" data-icon="üèÜ" title="Ver Ranking">
                üèÜ Ranking
            </button>
            <button class="btn btn-secondary btn-sm" onclick="backToMenu()" id="back-menu-btn" data-icon="üè†" title="Volver al Men√∫">
                üè† Volver al Men√∫
            </button>
            <button class="btn btn-secondary btn-sm" onclick="clearGuestProgress()" id="clear-progress-btn" style="display: none;" data-icon="üóëÔ∏è" title="Reiniciar Progreso">
                üóëÔ∏è Reiniciar Progreso
            </button>
            <button class="btn btn-secondary btn-sm" onclick="logout()" id="logout-btn" style="display: none;" data-icon="üö™" title="Cerrar Sesi√≥n">
                üö™ Cerrar Sesi√≥n
            </button>
        </div>
    </div>

    <script>
        // Configuraci√≥n del juego
        const CONFIG = {
            API_BASE_URL: 'https://colisan.com/sistema_apps_upload/sistema_apps_api/mundoletras/',
            GRID_SIZE: 6,
            MAX_ERRORS: 10
        };
        
        // Estado del juego
        let gameState = {
            currentUser: null,
            currentLevel: 1,
            score: 0,
            streak: 0,
            coins: 50,
            selectedCells: [],
            foundWords: [],
            currentGrid: [],
            currentWords: ['MAR', 'ALGA', 'CORAL', 'PECES'],
            // Sistema de mec√°nicas
            activeMechanics: [],
            originalGrid: [], // Para mec√°nica de niebla
            revealedCells: [], // Celdas reveladas de la niebla
            hiddenWords: [], // Palabras ocultas
            // Sistema de sonido
            soundEnabled: true,
            wordTimers: {}, // Timers por palabra
            dynamicTimer: null, // Timer din√°mico
            dynamicTimerInterval: null,
            wordTimerInterval: null,
            levelExpired: false, // Nivel expirado - no se puede continuar
            failedAttempts: 0 // N√∫mero de intentos fallidos en el nivel
        };
        
        // Funciones de navegaci√≥n
        function showScreen(screenId) {

            // Remover clase active de todas las pantallas
            document.querySelectorAll('.screen').forEach(s => {
                s.classList.remove('active');

            });
            
            // Mostrar pantalla solicitada
            const targetScreen = document.getElementById(screenId);
            if (targetScreen) {
                targetScreen.classList.add('active');

            } else {
                console.error('‚ùå Pantalla no encontrada:', screenId);
            }
        }
        
        function startAsGuest() {
            gameState.currentUser = {
                isGuest: true,
                name: 'Invitado',
                key: 'guest_' + Date.now()
            };
            
            showMessage('¬°Bienvenido! Iniciando juego...', 'success');
            setTimeout(async () => {
                try {
                    await initGame();
                    showScreen('game-screen');

                } catch (error) {
                    console.error('Error iniciando juego:', error);
                    showMessage('Error iniciando el juego. Intenta de nuevo.', 'error');
                }
            }, 1500);
        }
        
        function showLogin() {
            const loginContent = document.getElementById('login-content');
            loginContent.innerHTML = `
                <!-- Pesta√±as -->
                <div class="tabs-container">
                    <div class="tabs">
                        <button class="tab-btn active" onclick="switchTab('login')" id="tab-login">
                            üîë Iniciar Sesi√≥n
                        </button>
                        <button class="tab-btn" onclick="switchTab('register')" id="tab-register">
                            üìù Registro
                        </button>
                    </div>
                </div>
                
                <!-- Contenido de pesta√±as -->
                <div class="tab-content">
                    <!-- Pesta√±a de Login -->
                    <div id="login-tab" class="tab-panel active">
                        <div style="text-align: left;">
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Email:</label>
                                <input type="email" id="login-email" placeholder="tu@email.com" 
                                       style="width: 100%; padding: 0.75rem; border: none; border-radius: 0.5rem; font-size: 16px;">
                            </div>
                            <div style="margin-bottom: 1.5rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Contrase√±a:</label>
                                <input type="password" id="login-password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                                       style="width: 100%; padding: 0.75rem; border: none; border-radius: 0.5rem; font-size: 16px;">
                            </div>
                        </div>
                        
                        <button class="btn btn-primary" onclick="doLogin()">
                            üîë Iniciar Sesi√≥n
                        </button>
                    </div>
                    
                    <!-- Pesta√±a de Registro -->
                    <div id="register-tab" class="tab-panel">
                        <div style="text-align: left;">
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Nombre:</label>
                                <input type="text" id="register-name" placeholder="Tu nombre completo" 
                                       style="width: 100%; padding: 0.75rem; border: none; border-radius: 0.5rem; font-size: 16px;">
                            </div>
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Nick:</label>
                                <input type="text" id="register-nick" placeholder="Tu nick √∫nico" 
                                       style="width: 100%; padding: 0.75rem; border: none; border-radius: 0.5rem; font-size: 16px;">
                            </div>
                            <div style="margin-bottom: 1rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Email:</label>
                                <input type="email" id="register-email" placeholder="tu@email.com" 
                                       style="width: 100%; padding: 0.75rem; border: none; border-radius: 0.5rem; font-size: 16px;">
                            </div>
                            <div style="margin-bottom: 1.5rem;">
                                <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Contrase√±a:</label>
                                <input type="password" id="register-password" placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                                       style="width: 100%; padding: 0.75rem; border: none; border-radius: 0.5rem; font-size: 16px;">
                            </div>
                        </div>
                        
                        <button class="btn btn-primary" onclick="doRegister()">
                            üìù Crear Cuenta
                        </button>
                    </div>
                </div>
                
                <button class="btn btn-secondary" onclick="backToMainMenu()">
                    ‚Üê Volver
                </button>
            `;
        }
        
        // Funci√≥n para cambiar entre pesta√±as
        function switchTab(tabName) {
            // Ocultar todas las pesta√±as
            document.querySelectorAll('.tab-panel').forEach(panel => {
                panel.classList.remove('active');
            });
            
            // Desactivar todos los botones de pesta√±a
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Mostrar la pesta√±a seleccionada
            document.getElementById(tabName + '-tab').classList.add('active');
            document.getElementById('tab-' + tabName).classList.add('active');
        }
        
        function backToMainMenu() {
            const loginContent = document.getElementById('login-content');
            loginContent.innerHTML = `
                <button class="btn btn-primary" onclick="startAsGuest()">
                    üë§ Jugar como Invitado
                </button>
                
                <button class="btn btn-secondary" onclick="showLogin()">
                    üîê Identificarse
                </button>
            `;
        }
        
        async function doLogin() {
            const email = document.getElementById('login-email').value;
            const password = document.getElementById('login-password').value;
            
            if (!email || !password) {
                showMessage('Por favor completa todos los campos', 'error');
                return;
            }
            
            showMessage('Iniciando sesi√≥n...', 'success');
            
            try {
                const response = await fetch(CONFIG.API_BASE_URL + 'auth.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'login',
                        email: email,
                        password: password
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    gameState.currentUser = {
                        isGuest: false,
                        key: data.data.user.usuario_aplicacion_key,
                        ...data.data.user
                    };

                    showMessage('¬°Bienvenido de vuelta! Iniciando juego...', 'success');
                    setTimeout(async () => {
                        await initGame();
                        showScreen('game-screen');
                    }, 1500);
                } else {
                    showMessage(data.message || 'Error en el login', 'error');
                }
            } catch (error) {
                console.error('Error:', error);
                showMessage('Error de conexi√≥n. Intenta de nuevo.', 'error');
            }
        }
        
        async function doRegister() {
            const name = document.getElementById('register-name').value;
            const nick = document.getElementById('register-nick').value;
            const email = document.getElementById('register-email').value;
            const password = document.getElementById('register-password').value;
            
            if (!name || !nick || !email || !password) {
                showMessage('Por favor completa todos los campos', 'error');
                return;
            }
            
            if (password.length < 6) {
                showMessage('La contrase√±a debe tener al menos 6 caracteres', 'error');
                return;
            }
            
            if (nick.includes(' ')) {
                showMessage('El nick no puede contener espacios', 'error');
                return;
            }
            
            if (!email.includes('@') || !email.includes('.')) {
                showMessage('Por favor introduce un email v√°lido', 'error');
                return;
            }
            
            showMessage('Creando cuenta...', 'success');
            
            try {

                const response = await fetch(CONFIG.API_BASE_URL + 'auth.php', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        action: 'register',
                        email: email,
                        password: password,
                        nombre: name,
                        nick: nick
                    })
                });

                const responseText = await response.text();

                let data;
                try {
                    data = JSON.parse(responseText);
                } catch (parseError) {
                    console.error('‚ùå Error parseando JSON:', parseError);
                    showMessage('Error en la respuesta del servidor. Intenta de nuevo.', 'error');
                    return;
                }

                if (!response.ok) {
                    // Mostrar el mensaje espec√≠fico del servidor
                    const errorMsg = data.message || 'Error desconocido en el registro';
                    console.error('‚ùå Error del servidor:', errorMsg);
                    showMessage(errorMsg, 'error');
                    
                    // Volver a la pantalla de registro despu√©s de mostrar el error
                    setTimeout(() => {
                        showRegister();
                    }, 2000);
                    return;
                }

                if (data.success) {
                    showMessage('¬°Cuenta creada! Revisa tu email para el c√≥digo de verificaci√≥n.', 'success');
                    setTimeout(() => {
                        showVerification(email, password);
                    }, 2000);
                } else {
                    const errorMsg = data.message || 'Error desconocido en el registro';
                    console.error('‚ùå Error del servidor:', errorMsg);
                    showMessage(errorMsg, 'error');
                    
                    // Volver a la pantalla de registro despu√©s de mostrar el error
                    setTimeout(() => {
                        showRegister();
                    }, 2000);
                }
            } catch (error) {
                console.error('‚ùå Error en registro:', error);
                let errorMessage = 'Error de conexi√≥n. Intenta de nuevo.';
                
                if (error.message.includes('HTTP 500')) {
                    errorMessage = 'Error del servidor. Intenta m√°s tarde.';
                } else if (error.message.includes('HTTP 400')) {
                    errorMessage = 'Datos inv√°lidos. Revisa los campos.';
                } else if (error.message.includes('HTTP 409')) {
                    errorMessage = 'Conflicto de datos. Revisa la informaci√≥n.';
                }
                
                showMessage(errorMessage, 'error');
                
                // Volver a la pantalla de registro despu√©s de mostrar el error
                setTimeout(() => {
                    showRegister();
                }, 2000);
            }
        }
        
        function showVerification(email, password) {
            const loginContent = document.getElementById('login-content');
            loginContent.innerHTML = `
                <div style="text-align: center; margin-bottom: 1.5rem;">
                    <div style="font-size: 3rem; margin-bottom: 1rem;">üìß</div>
                    <p style="margin-bottom: 0.5rem;">C√≥digo enviado a:</p>
                    <p style="font-weight: bold; color: #fbbf24;">${email}</p>
                </div>
                
                <div style="margin-bottom: 1.5rem;">
                    <label style="display: block; margin-bottom: 0.5rem; font-weight: 600; text-align: center;">C√≥digo de Verificaci√≥n:</label>
                    <input type="text" id="verify-code" placeholder="123456" maxlength="6"
                           style="width: 100%; padding: 0.75rem; border: none; border-radius: 0.5rem; font-size: 18px; text-align: center; letter-spacing: 0.2em;">
                </div>
                
                <button class="btn btn-primary" onclick="doVerify('${email}', '${password}')">
                    ‚úÖ Verificar C√≥digo
                </button>
                
                <button class="btn btn-secondary" onclick="backToMainMenu()">
                    ‚Üê Volver
                </button>
            `;
        }
        
        async function doVerify(email, password) {
            const code = document.getElementById('verify-code').value;
            
            if (!code || code.length !== 6) {
                showMessage('Por favor introduce el c√≥digo de 6 d√≠gitos', 'error');
                return;
            }
            
            showMessage('Verificando c√≥digo...', 'success');
            
            try {
                const response = await fetch(CONFIG.API_BASE_URL + 'auth.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'verify',
                        code: code
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showMessage('¬°Cuenta verificada! Iniciando sesi√≥n...', 'success');
                    
                    // Auto-login despu√©s de verificar
                    setTimeout(async () => {
                        const loginResponse = await fetch(CONFIG.API_BASE_URL + 'auth.php', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                action: 'login',
                                email: email,
                                password: password
                            })
                        });
                        
                        const loginData = await loginResponse.json();
                        
                        if (loginData.success) {
                            gameState.currentUser = {
                                isGuest: false,
                                key: loginData.data.user.usuario_aplicacion_key,
                                ...loginData.data.user
                            };

                            await initGame();
                            showScreen('game-screen');
                        }
                    }, 1500);
                } else {
                    showMessage(data.message || 'C√≥digo incorrecto', 'error');
                }
            } catch (error) {
                console.error('Error:', error);
                showMessage('Error de conexi√≥n. Intenta de nuevo.', 'error');
            }
        }
        
        function backToMenu() {
            showScreen('login-screen');
        }
        
        function logout() {
            // Limpiar estado del usuario
            gameState.currentUser = null;
            gameState.currentLevel = 1;
            gameState.score = 0;
            gameState.streak = 0;
            gameState.coins = 50;
            gameState.selectedCells = [];
            gameState.foundWords = [];
            
            showMessage('Sesi√≥n cerrada. Volviendo al men√∫...', 'success');
            setTimeout(() => {
                showScreen('login-screen');
            }, 1500);
        }
        
        // Funci√≥n de debug para probar directamente
        
        // Funciones de mensajes
        function showMessage(text, type = 'success') {
            const container = document.getElementById('message-container');
            container.innerHTML = `<div class="message ${type}">${text}</div>`;
            setTimeout(() => {
                container.innerHTML = '';
            }, 3000);
        }
        
        // Animaci√≥n de puntuaci√≥n
        function animateScore(scoreElement, points) {
            scoreElement.classList.add('score-animation');
            const originalScore = parseInt(scoreElement.textContent);
            const targetScore = originalScore + points;
            
            // Animaci√≥n de incremento gradual
            let currentScore = originalScore;
            const increment = Math.ceil(points / 10);
            const interval = setInterval(() => {
                currentScore += increment;
                if (currentScore >= targetScore) {
                    currentScore = targetScore;
                    clearInterval(interval);
                    scoreElement.classList.remove('score-animation');
                }
                scoreElement.textContent = currentScore;
            }, 50);
        }
        
        // Animaci√≥n de monedas mejorada
        function animateCoins(coinsElement, amount = 10) {
            console.log('üí∞ Animando monedas:', amount);
            // Solo animar si hay monedas para a√±adir
            if (amount <= 0) return;
            
            // Reproducir sonido primero
            playSound('coin');
            
            // Crear monedas volando desde las celdas encontradas
            createFlyingCoins(amount, coinsElement);
            
            // Actualizar el contador despu√©s de que las monedas lleguen
            setTimeout(() => {
                const currentCoins = parseInt(coinsElement.textContent);
                coinsElement.textContent = currentCoins + amount;
                console.log('üí∞ Monedas actualizadas:', currentCoins + amount);
                
                // Efecto en el contador
                coinsElement.classList.add('coin-count-animation');
                setTimeout(() => {
                    coinsElement.classList.remove('coin-count-animation');
                }, 600);
            }, 1200); // M√°s tiempo para ver la animaci√≥n de subida
        }
        
        function createFlyingCoins(amount, targetElement) {
            // Obtener posici√≥n de las celdas encontradas (√∫ltima palabra)
            const foundCells = document.querySelectorAll('.grid-cell.found');
            const targetRect = targetElement.getBoundingClientRect();
            
            // Si no hay celdas encontradas, usar posici√≥n central del grid
            let startX, startY;
            if (foundCells.length > 0) {
                const lastCell = foundCells[foundCells.length - 1];
                const cellRect = lastCell.getBoundingClientRect();
                startX = cellRect.left + cellRect.width / 2;
                startY = cellRect.top + cellRect.height / 2;
            } else {
                // Posici√≥n central del grid como fallback
                const grid = document.querySelector('.game-grid');
                if (grid) {
                    const gridRect = grid.getBoundingClientRect();
                    startX = gridRect.left + gridRect.width / 2;
                    startY = gridRect.top + gridRect.height / 2;
                } else {
                    startX = window.innerWidth / 2;
                    startY = window.innerHeight / 2;
                }
            }
            
            const targetX = targetRect.left + targetRect.width / 2;
            const targetY = targetRect.top + targetRect.height / 2;
            
            // Calcular diferencia
            const deltaX = targetX - startX;
            const deltaY = targetY - startY;
            
            // Crear m√∫ltiples monedas volando
            const numCoins = Math.min(amount, 5); // M√°ximo 5 monedas visuales
            
            for (let i = 0; i < numCoins; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'flying-coin';
                    coin.textContent = 'üí∞';
                    coin.style.left = startX + 'px';
                    coin.style.top = startY + 'px';
                    coin.style.setProperty('--target-x', deltaX + 'px');
                    coin.style.setProperty('--target-y', deltaY + 'px');
                    
                    document.body.appendChild(coin);
                    
                    // Remover despu√©s de la animaci√≥n
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                    }, 1200);
                }, i * 100); // Escalonar las monedas
            }
        }
        
        // Sistema de Ranking
        function showRanking() {
            console.log('üèÜ Mostrando ranking...');
            
            // Crear overlay
            const overlay = document.createElement('div');
            overlay.className = 'ranking-overlay';
            overlay.innerHTML = `
                <div class="ranking-content">
                    <div class="ranking-header">
                        <div class="ranking-title">
                            üèÜ Ranking Global
                        </div>
                        <button class="ranking-close" onclick="closeRanking()">√ó</button>
                    </div>
                    <div class="ranking-loading">
                        Cargando ranking...
                    </div>
                    <div class="ranking-controls">
                        <button class="ranking-btn" onclick="loadFullRanking()">Ver Top 50</button>
                        <button class="ranking-btn" onclick="loadUserContext()">Mi Posici√≥n</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Cargar ranking
            loadRanking();
        }
        
        function closeRanking() {
            console.log('üî¥ Intentando cerrar ranking...');
            const overlay = document.querySelector('.ranking-overlay');
            console.log('üî¥ Overlay encontrado:', overlay);
            if (overlay) {
                overlay.remove();
                console.log('‚úÖ Ranking cerrado exitosamente');
            } else {
                console.error('‚ùå No se encontr√≥ el overlay de ranking');
            }
        }
        
        async function loadRanking() {
            try {
                const userKey = gameState.currentUser ? gameState.currentUser.key : null;
                console.log('üîç UserKey para ranking:', userKey);
                
                if (userKey) {
                    // Cargar contexto del usuario (10 arriba + 10 abajo)
                    const url = `sistema_apps_api/mundoletras/ranking.php?action=user_context&user_key=${encodeURIComponent(userKey)}`;
                    console.log('üîç URL ranking:', url);
                    
                    const response = await fetch(url);
                    console.log('üîç Response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('üîç Response data:', data);
                    
                    if (data.success) {
                        displayRanking(data.data, true);
                    } else {
                        throw new Error(data.message || data.error || 'Error desconocido');
                    }
                } else {
                    // Cargar ranking completo
                    const url = 'sistema_apps_api/mundoletras/ranking.php?action=full';
                    console.log('üîç URL ranking completo:', url);
                    
                    const response = await fetch(url);
                    console.log('üîç Response status:', response.status);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    console.log('üîç Response data:', data);
                    
                    if (data.success) {
                        displayRanking(data.data, false);
                    } else {
                        throw new Error(data.message || data.error || 'Error desconocido');
                    }
                }
            } catch (error) {
                console.error('Error cargando ranking:', error);
                showRankingError('Error al cargar el ranking: ' + error.message);
            }
        }
        
        function displayRanking(rankingData, isUserContext = false) {
            const overlay = document.querySelector('.ranking-overlay');
            if (!overlay) return;
            
            // Limpiar completamente el contenido del overlay
            const contentArea = overlay.querySelector('.ranking-content');
            if (!contentArea) {
                console.error('No se encontr√≥ ranking-content');
                return;
            }
            
            let html = '';
            let controlsHtml = '';
            
            if (isUserContext) {
                // Mostrar contexto del usuario
                const ranking = rankingData.ranking;
                const userPosition = rankingData.user_position;
                const isGuest = rankingData.is_guest;
                
                // Si es usuario guest, mostrar mensaje
                if (isGuest) {
                    html += '<div style="text-align: center; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px; margin-bottom: 1rem;">';
                    html += '<strong>üë§ Usuario Invitado</strong><br>';
                    html += '<small>Ranking general - Reg√≠strate para ver tu posici√≥n</small>';
                    html += '</div>';
                }
                
                html += ranking.map(player => createRankingItem(player, player.usuario_aplicacion_key === gameState.currentUser?.key)).join('');
                
                controlsHtml = `
                    <div class="ranking-controls">
                        <button class="ranking-btn" onclick="loadFullRanking()">Ver Top 50</button>
                        <button class="ranking-btn" onclick="loadUserContext()">Mi Posici√≥n</button>
                    </div>
                `;
            } else {
                // Mostrar ranking completo
                const ranking = rankingData;
                html += ranking.map(player => createRankingItem(player, player.usuario_aplicacion_key === gameState.currentUser?.key)).join('');
                
                controlsHtml = `
                    <div class="ranking-controls">
                        <button class="ranking-btn" onclick="loadUserContext()">Mi Posici√≥n</button>
                        <button class="ranking-btn" onclick="loadFullRanking()">Actualizar</button>
                    </div>
                `;
            }
            
            // Reemplazar solo la lista, manteniendo el header
            const rankingList = contentArea.querySelector('.ranking-list') || contentArea.querySelector('.ranking-loading');
            if (rankingList) {
                rankingList.outerHTML = `<div class="ranking-list">${html}</div>`;
            } else {
                contentArea.innerHTML = `
                    <div class="ranking-list">
                        ${html}
                    </div>
                    ${controlsHtml}
                `;
            }
            
            // Actualizar controles si existen
            const existingControls = contentArea.querySelector('.ranking-controls');
            if (existingControls) {
                existingControls.outerHTML = controlsHtml;
            } else {
                contentArea.insertAdjacentHTML('beforeend', controlsHtml);
            }
        }
        
        function createRankingItem(player, isCurrentUser = false) {
            const position = player.posicion;
            const positionClass = position === 1 ? 'gold' : position === 2 ? 'silver' : position === 3 ? 'bronze' : '';
            const date = new Date(player.actualizado_at).toLocaleDateString('es-ES', { 
                day: '2-digit', 
                month: '2-digit' 
            });
            
            return `
                <div class="ranking-item ${isCurrentUser ? 'current-user' : ''}">
                    <div class="ranking-position ${positionClass}">
                        #${position}
                    </div>
                    <div class="ranking-player">
                        <div class="ranking-name">${player.nombre}</div>
                        <div class="ranking-level">Nivel ${player.nivel_max}</div>
                    </div>
                    <div class="ranking-stats">
                        <div class="ranking-score">${player.puntuacion_total.toLocaleString()}</div>
                        <div class="ranking-date">${date}</div>
                    </div>
                </div>
            `;
        }
        
        async function loadFullRanking() {
            try {
                console.log('üîç Cargando ranking completo...');
                const response = await fetch('sistema_apps_api/mundoletras/ranking.php?action=full');
                console.log('üîç Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üîç Ranking completo data:', data);
                
                if (data.success) {
                    displayRanking(data.data, false);
                } else {
                    throw new Error(data.message || data.error || 'Error desconocido');
                }
            } catch (error) {
                console.error('Error cargando ranking completo:', error);
                showRankingError('Error al cargar el ranking completo: ' + error.message);
            }
        }
        
        async function loadUserContext() {
            try {
                const userKey = gameState.currentUser ? gameState.currentUser.key : null;
                if (!userKey) {
                    showRankingError('Debes estar registrado para ver tu posici√≥n');
                    return;
                }
                
                console.log('üîç Cargando contexto del usuario:', userKey);
                const url = `sistema_apps_api/mundoletras/ranking.php?action=user_context&user_key=${encodeURIComponent(userKey)}`;
                console.log('üîç URL contexto:', url);
                
                const response = await fetch(url);
                console.log('üîç Response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üîç Contexto data:', data);
                
                if (data.success) {
                    displayRanking(data.data, true);
                } else {
                    throw new Error(data.message || data.error || 'Error desconocido');
                }
            } catch (error) {
                console.error('Error cargando contexto del usuario:', error);
                showRankingError('Error al cargar tu posici√≥n: ' + error.message);
            }
        }
        
        function showRankingError(message) {
            const overlay = document.querySelector('.ranking-overlay');
            if (!overlay) return;
            
            const contentArea = overlay.querySelector('.ranking-content');
            if (!contentArea) {
                console.error('No se encontr√≥ ranking-content para mostrar error');
                return;
            }
            
            contentArea.innerHTML = `
                <div class="ranking-error">
                    ${message}
                    <br><br>
                    <button class="ranking-btn" onclick="testRankingConnection()">üîß Test Conexi√≥n</button>
                    <button class="ranking-btn" onclick="checkTableStructure()">üìã Ver Estructura</button>
                    <button class="ranking-btn" onclick="testSQLQuery()">üîç Test SQL</button>
                    <button class="ranking-btn" onclick="loadRanking()">Reintentar</button>
                </div>
            `;
        }
        
        async function testRankingConnection() {
            try {
                console.log('üîß Probando conexi√≥n del ranking...');
                const response = await fetch('sistema_apps_api/mundoletras/ranking.php?action=test');
                console.log('üîß Test response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üîß Test data:', data);
                
                if (data.success) {
                    showRankingError(`
                        ‚úÖ Test de conexi√≥n exitoso<br>
                        üìä Tablas existentes: ${data.data.tables_exist.join(', ')}<br>
                        üîó Conexi√≥n BD: ${data.data.db_connection}<br>
                        üìã Todas las tablas: ${data.data.all_tables ? 'S√ç' : 'NO'}
                    `);
                } else {
                    throw new Error(data.message || 'Error en test');
                }
            } catch (error) {
                console.error('Error en test de conexi√≥n:', error);
                showRankingError('‚ùå Error en test de conexi√≥n: ' + error.message);
            }
        }
        
        async function checkTableStructure() {
            try {
                console.log('üìã Verificando estructura de tablas...');
                const response = await fetch('sistema_apps_api/mundoletras/ranking.php?action=structure');
                console.log('üìã Structure response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üìã Structure data:', data);
                
                if (data.success) {
                    let structureInfo = 'üìã Estructura de tablas:<br><br>';
                    
                    // Mostrar estructura de usuarios_aplicaciones
                    if (data.data.usuarios_aplicaciones && !data.data.usuarios_aplicaciones.error) {
                        structureInfo += '<strong>usuarios_aplicaciones:</strong><br>';
                        data.data.usuarios_aplicaciones.forEach(field => {
                            structureInfo += `‚Ä¢ ${field.Field} (${field.Type})<br>`;
                        });
                        structureInfo += '<br>';
                    } else {
                        structureInfo += '‚ùå Error en usuarios_aplicaciones: ' + (data.data.usuarios_aplicaciones?.error || 'No encontrada') + '<br><br>';
                    }
                    
                    // Mostrar estructura de mundoletras_progreso
                    if (data.data.mundoletras_progreso && !data.data.mundoletras_progreso.error) {
                        structureInfo += '<strong>mundoletras_progreso:</strong><br>';
                        data.data.mundoletras_progreso.forEach(field => {
                            structureInfo += `‚Ä¢ ${field.Field} (${field.Type})<br>`;
                        });
                    } else {
                        structureInfo += '‚ùå Error en mundoletras_progreso: ' + (data.data.mundoletras_progreso?.error || 'No encontrada');
                    }
                    
                    showRankingError(structureInfo);
                } else {
                    throw new Error(data.message || 'Error obteniendo estructura');
                }
            } catch (error) {
                console.error('Error verificando estructura:', error);
                showRankingError('‚ùå Error verificando estructura: ' + error.message);
            }
        }
        
        async function testSQLQuery() {
            try {
                console.log('üîç Probando consulta SQL...');
                const response = await fetch('sistema_apps_api/mundoletras/ranking.php?action=test_sql');
                console.log('üîç SQL Test response status:', response.status);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log('üîç SQL Test data:', data);
                
                if (data.success) {
                    let sqlInfo = 'üîç Test de consulta SQL:<br><br>';
                    sqlInfo += `<strong>Estado:</strong> ${data.data.sql_test}<br>`;
                    sqlInfo += `<strong>Usuarios en BD:</strong> ${data.data.users_count}<br>`;
                    sqlInfo += `<strong>Progresos en BD:</strong> ${data.data.progress_count}<br>`;
                    sqlInfo += `<strong>JOIN test:</strong> ${data.data.join_test_count} registros<br>`;
                    sqlInfo += `<strong>Ranking final:</strong> ${data.data.ranking_count} registros<br>`;
                    sqlInfo += `<strong>Todos los progresos:</strong> ${data.data.all_progress_count} registros<br><br>`;
                    
                    if (data.data.join_sample && data.data.join_sample.length > 0) {
                        sqlInfo += '<strong>Muestra de JOIN:</strong><br>';
                        data.data.join_sample.forEach((player, index) => {
                            sqlInfo += `${index + 1}. ${player.nombre} - App: ${player.app_codigo} - Activo: ${player.activo} - Nivel: ${player.nivel_max || 'N/A'}<br>`;
                        });
                        sqlInfo += '<br>';
                    }
                    
                    if (data.data.all_progress_sample && data.data.all_progress_sample.length > 0) {
                        sqlInfo += '<strong>Todos los progresos (sin JOIN):</strong><br>';
                        data.data.all_progress_sample.forEach((progress, index) => {
                            sqlInfo += `${index + 1}. Key: ${progress.usuario_aplicacion_key} - Nivel: ${progress.nivel_max} - Puntos: ${progress.puntuacion_total}<br>`;
                        });
                        sqlInfo += '<br>';
                    }
                    
                    if (data.data.ranking_sample && data.data.ranking_sample.length > 0) {
                        sqlInfo += '<strong>Muestra de ranking (con JOIN):</strong><br>';
                        data.data.ranking_sample.forEach((player, index) => {
                            sqlInfo += `${index + 1}. ${player.nombre} - Nivel: ${player.nivel_max} - Puntos: ${player.puntuacion_total}<br>`;
                        });
                    } else {
                        sqlInfo += '<strong>‚ö†Ô∏è No hay datos de ranking</strong>';
                    }
                    
                    showRankingError(sqlInfo);
                } else {
                    let errorInfo = '‚ùå Error en test SQL:<br><br>';
                    errorInfo += `<strong>Error:</strong> ${data.data.error}<br><br>`;
                    if (data.data.trace) {
                        errorInfo += '<strong>Trace:</strong><br>';
                        errorInfo += `<small>${data.data.trace}</small>`;
                    }
                    showRankingError(errorInfo);
                }
            } catch (error) {
                console.error('Error en test SQL:', error);
                showRankingError('‚ùå Error en test SQL: ' + error.message);
            }
        }
        
        // Sistema de sonido
        function toggleSound() {
            gameState.soundEnabled = !gameState.soundEnabled;
            const soundControl = document.getElementById('sound-control');
            if (gameState.soundEnabled) {
                soundControl.textContent = 'üîä';
                soundControl.classList.remove('muted');
                playSound('toggle');
            } else {
                soundControl.textContent = 'üîá';
                soundControl.classList.add('muted');
            }
        }
        
        function playSound(type) {
            if (!gameState.soundEnabled) return;
            
            try {
                // Crear audio context si no existe
                if (!window.audioContext) {
                    window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                const ctx = window.audioContext;
                
                // Resumir contexto si est√° suspendido (requerido por algunos navegadores)
                if (ctx.state === 'suspended') {
                    ctx.resume().catch(() => {});
                }
                
                switch(type) {
                    case 'word':
                        // Sonido al encontrar palabra
                        const wordOscillator = ctx.createOscillator();
                        const wordGain = ctx.createGain();
                        wordOscillator.connect(wordGain);
                        wordGain.connect(ctx.destination);
                        wordOscillator.frequency.setValueAtTime(800, ctx.currentTime);
                        wordOscillator.frequency.exponentialRampToValueAtTime(1200, ctx.currentTime + 0.1);
                        wordGain.gain.setValueAtTime(0.1, ctx.currentTime);
                        wordGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                        wordOscillator.start(ctx.currentTime);
                        wordOscillator.stop(ctx.currentTime + 0.3);
                        break;
                        
                    case 'level':
                        // Sonido al completar nivel
                        const levelOscillator = ctx.createOscillator();
                        const levelGain = ctx.createGain();
                        levelOscillator.connect(levelGain);
                        levelGain.connect(ctx.destination);
                        levelOscillator.frequency.setValueAtTime(523, ctx.currentTime); // C5
                        levelOscillator.frequency.setValueAtTime(659, ctx.currentTime + 0.2); // E5
                        levelOscillator.frequency.setValueAtTime(784, ctx.currentTime + 0.4); // G5
                        levelGain.gain.setValueAtTime(0.15, ctx.currentTime);
                        levelGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.6);
                        levelOscillator.start(ctx.currentTime);
                        levelOscillator.stop(ctx.currentTime + 0.6);
                        break;
                        
                    case 'coin':
                        // Sonido de moneda
                        const coinOscillator = ctx.createOscillator();
                        const coinGain = ctx.createGain();
                        coinOscillator.connect(coinGain);
                        coinGain.connect(ctx.destination);
                        coinOscillator.frequency.setValueAtTime(1000, ctx.currentTime);
                        coinOscillator.frequency.exponentialRampToValueAtTime(2000, ctx.currentTime + 0.1);
                        coinGain.gain.setValueAtTime(0.1, ctx.currentTime);
                        coinGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                        coinOscillator.start(ctx.currentTime);
                        coinOscillator.stop(ctx.currentTime + 0.2);
                        break;
                        
                    case 'toggle':
                        // Sonido al cambiar configuraci√≥n
                        const toggleOscillator = ctx.createOscillator();
                        const toggleGain = ctx.createGain();
                        toggleOscillator.connect(toggleGain);
                        toggleGain.connect(ctx.destination);
                        toggleOscillator.frequency.setValueAtTime(400, ctx.currentTime);
                        toggleGain.gain.setValueAtTime(0.05, ctx.currentTime);
                        toggleGain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                        toggleOscillator.start(ctx.currentTime);
                        toggleOscillator.stop(ctx.currentTime + 0.1);
                        break;
                }
            } catch (error) {
                console.log('üîá Error reproduciendo sonido:', error);
                // Silenciar errores de audio para no bloquear el juego
            }
        }
        
        // Mostrar mensaje de nivel completado
        function showLevelComplete() {
            console.log('üéâ Mostrando mensaje de nivel completado');
            // Crear overlay
            const overlay = document.createElement('div');
            overlay.className = 'level-complete-overlay';
            overlay.innerHTML = `
                <div class="level-complete-content">
                    <div class="level-complete-title">üéâ ¬°NIVEL COMPLETADO!</div>
                    <div class="level-complete-subtitle">¬°Excelente trabajo!</div>
                    <div class="level-complete-stats">
                        <div class="level-complete-stat">
                            <div class="level-complete-stat-value">${gameState.currentLevel}</div>
                            <div class="level-complete-stat-label">Nivel</div>
                        </div>
                        <div class="level-complete-stat">
                            <div class="level-complete-stat-value">${gameState.foundWords.length}</div>
                            <div class="level-complete-stat-label">Palabras</div>
                        </div>
                        <div class="level-complete-stat">
                            <div class="level-complete-stat-value">${gameState.score}</div>
                            <div class="level-complete-stat-label">Puntos</div>
                        </div>
                    </div>
                    <div style="margin-top: 1rem; color: #e0e7ff; font-size: 1rem;">
                        Pasando al siguiente nivel...
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            console.log('üéâ Overlay a√±adido al DOM');
            
            // Remover overlay despu√©s de la animaci√≥n
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                    console.log('üéâ Overlay removido del DOM');
                }
            }, 4000);
        }
        
        // Animaci√≥n cuando se encuentra una palabra
        function animateWordFound(word) {
            // Buscar la palabra en la lista y animarla
            const wordElements = document.querySelectorAll('.word-item');
            wordElements.forEach(element => {
                if (element.textContent.includes(word)) {
                    element.classList.add('word-found-animation');
                    setTimeout(() => {
                        element.classList.remove('word-found-animation');
                    }, 500);
                }
            });
        }
        
        // Funci√≥n de debug para verificar palabras en el grid
        function debugWordPlacement() {
            console.log('üîç === VERIFICACI√ìN DE PALABRAS EN GRID ===');
            console.log('üìù Palabras que deber√≠an estar:', gameState.currentWords);
            console.log('üìè Grid size:', Math.sqrt(gameState.currentGrid.length));
            
            gameState.currentWords.forEach(word => {
                console.log(`\nüîç Buscando "${word}" (${word.length} letras):`);
                
                const gridSize = Math.sqrt(gameState.currentGrid.length);
                let found = false;
                
                // Buscar en todas las direcciones
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        const startIndex = row * gridSize + col;
                        
                        // Direcciones: horizontal, vertical, diagonal-der, diagonal-izq
                        const directions = [
                            { dr: 0, dc: 1, name: 'horizontal' },
                            { dr: 1, dc: 0, name: 'vertical' },
                            { dr: 1, dc: 1, name: 'diagonal-der' },
                            { dr: 1, dc: -1, name: 'diagonal-izq' }
                        ];
                        
                        directions.forEach(dir => {
                            let currentWord = '';
                            let valid = true;
                            
                            for (let i = 0; i < word.length; i++) {
                                const checkRow = row + (dir.dr * i);
                                const checkCol = col + (dir.dc * i);
                                
                                if (checkRow >= 0 && checkRow < gridSize && checkCol >= 0 && checkCol < gridSize) {
                                    const index = checkRow * gridSize + checkCol;
                                    // Usar originalGrid si est√° disponible (para mec√°nica de niebla), sino currentGrid
                                    const letter = gameState.originalGrid && gameState.originalGrid[index] ? gameState.originalGrid[index] : gameState.currentGrid[index];
                                    currentWord += letter;
                                } else {
                                    valid = false;
                                    break;
                                }
                            }
                            
                            if (valid && (currentWord === word || currentWord === word.split('').reverse().join(''))) {
                                console.log(`‚úÖ "${word}" encontrada en (${row},${col}) direcci√≥n ${dir.name}`);
                                console.log(`   Palabra en grid: "${currentWord}"`);
                                found = true;
                            }
                        });
                    }
                }
                
                if (!found) {
                    console.log(`‚ùå "${word}" NO ENCONTRADA en el grid`);
                }
            });
            
            console.log('\nüìä Grid completo:');
            const gridSize = Math.sqrt(gameState.currentGrid.length);
            for (let row = 0; row < gridSize; row++) {
                let rowStr = '';
                for (let col = 0; col < gridSize; col++) {
                    const index = row * gridSize + col;
                    rowStr += gameState.currentGrid[index] + ' ';
                }
                console.log(`Fila ${row}: ${rowStr}`);
            }
            console.log('üîç === FIN VERIFICACI√ìN ===');
        }
        
        // Funciones de localStorage para invitados
        function saveGuestProgress() {
            if (gameState.currentUser && gameState.currentUser.isGuest) {
                const progressData = {
                    currentLevel: gameState.currentLevel,
                    score: gameState.score,
                    streak: gameState.streak,
                    coins: gameState.coins,
                    foundWords: gameState.foundWords,
                    timestamp: Date.now()
                };
                
                try {
                    localStorage.setItem('mundoletras_guest_progress', JSON.stringify(progressData));

                } catch (error) {
                    console.error('‚ùå Error guardando progreso:', error);
                }
            } else {

            }
        }
        
        // Funciones de BBDD para usuarios registrados
        async function loadUserProgress() {
            if (!gameState.currentUser || gameState.currentUser.isGuest) {

                return;
            }
            
            try {

                const response = await fetch(CONFIG.API_BASE_URL + 'progress.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'get',
                        usuario_aplicacion_key: gameState.currentUser.usuario_aplicacion_key
                    })
                });
                
                const data = await response.json();

                if (data.success && data.data) {
                    gameState.currentLevel = data.data.nivel_max || 1;
                    gameState.coins = data.data.monedas || 50;
                    gameState.score = data.data.puntuacion_total || 0;

                    showMessage(`¬°Bienvenido de vuelta! Nivel ${gameState.currentLevel}`, 'success');
                } else {

                    gameState.currentLevel = 1;
                    gameState.coins = 50;
                    gameState.score = 0;
                }
            } catch (error) {
                console.error('‚ùå Error cargando progreso de usuario:', error);
                gameState.currentLevel = 1;
                gameState.coins = 50;
                gameState.score = 0;
            }
        }
        
        async function saveUserProgress() {
            if (!gameState.currentUser || gameState.currentUser.isGuest) {

                return;
            }
            
            try {

                const response = await fetch(CONFIG.API_BASE_URL + 'progress.php', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'save',
                        usuario_aplicacion_key: gameState.currentUser.usuario_aplicacion_key,
                        nivel_max: gameState.currentLevel,
                        monedas: gameState.coins,
                        puntuacion_total: gameState.score
                    })
                });
                
                const data = await response.json();

                if (data.success) {

                } else {
                    console.error('‚ùå Error guardando progreso:', data.message);
                }
            } catch (error) {
                console.error('‚ùå Error guardando progreso de usuario:', error);
            }
        }
        
        function loadGuestProgress() {
            try {
                const savedProgress = localStorage.getItem('mundoletras_guest_progress');

                if (savedProgress) {
                    const progressData = JSON.parse(savedProgress);

                    // Verificar que no sea muy antiguo (m√°ximo 30 d√≠as)
                    const maxAge = 30 * 24 * 60 * 60 * 1000; // 30 d√≠as en ms
                    const age = Date.now() - progressData.timestamp;

                    if (age < maxAge) {
                        gameState.currentLevel = progressData.currentLevel || 1;
                        gameState.score = progressData.score || 0;
                        gameState.streak = progressData.streak || 0;
                        gameState.coins = progressData.coins || 50;
                        gameState.foundWords = progressData.foundWords || [];

                        showMessage(`¬°Bienvenido de vuelta! Nivel ${gameState.currentLevel}`, 'success');
                    } else {

                        resetGuestProgress();
                    }
                } else {

                    resetGuestProgress();
                }
            } catch (error) {
                console.error('‚ùå Error cargando progreso:', error);
                resetGuestProgress();
            }
        }
        
        function resetGuestProgress() {
            gameState.currentLevel = 1;
            gameState.score = 0;
            gameState.streak = 0;
            gameState.coins = 50;
            gameState.selectedCells = [];
            gameState.foundWords = [];
        }
        
        function clearGuestProgress() {
            try {
                localStorage.removeItem('mundoletras_guest_progress');

                showMessage('Progreso eliminado. Reiniciando desde el nivel 1.', 'success');
                resetGuestProgress();
            } catch (error) {
                console.error('Error eliminando progreso:', error);
            }
        }
        
        // Inicializar juego
        async function initGame() {
            // Cargar progreso seg√∫n tipo de usuario
            if (gameState.currentUser && gameState.currentUser.isGuest) {
                // Invitado: cargar de localStorage
                loadGuestProgress();
            } else if (gameState.currentUser && !gameState.currentUser.isGuest) {
                // Usuario registrado: cargar de BBDD
                await loadUserProgress();
            }
            
            // Configurar palabras del nivel actual
            gameState.currentWords = getLevelWords(gameState.currentLevel);
            
            // El grid ahora es din√°mico basado en las palabras, no fijo por nivel
            // CONFIG.GRID_SIZE ya no se usa - se calcula din√°micamente
            
            // Mostrar/ocultar bot√≥n de reiniciar progreso para invitados
            const clearProgressBtn = document.getElementById('clear-progress-btn');
            if (clearProgressBtn) {
                clearProgressBtn.style.display = (gameState.currentUser && gameState.currentUser.isGuest) ? 'inline-flex' : 'none';
            }
            
            // Actualizar informaci√≥n del usuario
            updateUserInfo();
            
            generateGrid();
            updateHUD();
            
            // Generar y aplicar mec√°nicas aleatorias DESPU√âS de generar el grid
            const randomMechanics = generateRandomMechanics(gameState.currentLevel);
            applyMechanics(randomMechanics);
            
            // Actualizar lista de palabras DESPU√âS de aplicar mec√°nicas
            updateWordsList();
            
            // Aplicar mec√°nicas visuales despu√©s de inicializar el juego
            setTimeout(() => {
                applyVisualMechanics();
            }, 200);
        }
        
        // Generar siguiente nivel
        function generateNextLevel() {
            console.log('üîÑ Generando siguiente nivel...');
            
            // LIMPIAR mec√°nicas del nivel anterior
            gameState.activeMechanics = [];
            gameState.originalGrid = [];
            gameState.revealedCells = [];
            gameState.hiddenWords = [];
            gameState.wordTimers = {};
            gameState.dynamicTimer = null; // Limpiar timer din√°mico
            gameState.levelExpired = false;
            gameState.failedAttempts = 0;
            gameState.selectedCells = [];
            gameState.foundWords = []; // Limpiar palabras encontradas
            
            // Limpiar timers del nivel anterior
            if (gameState.dynamicTimerInterval) {
                clearInterval(gameState.dynamicTimerInterval);
                gameState.dynamicTimerInterval = null;
                console.log('üßπ Timer din√°mico limpiado para nuevo nivel');
            }
            if (gameState.wordTimerInterval) {
                clearInterval(gameState.wordTimerInterval);
                gameState.wordTimerInterval = null;
                console.log('üßπ Timer de palabras limpiado para nuevo nivel');
            }
            
            // Cambiar palabras seg√∫n el nivel
            const levelWords = getLevelWords(gameState.currentLevel);
            gameState.currentWords = levelWords;
            
            // La dificultad ahora se maneja con el n√∫mero y tipo de palabras, no con grid fijo
            // El grid se calcula din√°micamente basado en las palabras seleccionadas
            
            generateGrid();
            updateHUD();
            
            // Generar y aplicar mec√°nicas aleatorias DESPU√âS de generar el grid
            const randomMechanics = generateRandomMechanics(gameState.currentLevel);
            applyMechanics(randomMechanics);
            
            // Actualizar lista de palabras DESPU√âS de aplicar mec√°nicas
            updateWordsList();
            
            // Aplicar mec√°nicas visuales despu√©s de generar el nuevo nivel
            setTimeout(() => {
                applyVisualMechanics();
            }, 200);
        }
        
        // Obtener palabras seg√∫n el nivel
        function getLevelWords(level) {
            // Inicializar cache de palabras usadas si no existe
            if (!gameState.usedWords) {
                gameState.usedWords = {
                    short: new Set(),
                    ocean: new Set(), 
                    forest: new Set(),
                    advanced: new Set()
                };
            }
            // Bancos de palabras por categor√≠a - Ampliados para m√°s variedad
            const wordBanks = {
                // Niveles 1-3: Palabras cortas (3-4 letras)
                short: [
                    'MAR', 'SOL', 'LUNA', 'CASA', 'AGUA', 'FUEGO', 'AIRE', 'TIERRA', 
                    'GATO', 'PERRO', 'PATO', 'OSO', 'FLOR', 'MESA', 'SILLA', 'VENTANA',
                    'PESO', 'MANO', 'CARA', 'BOCA', 'PIES', 'OJOS', 'CABO', 'MAPA',
                    'SAL', 'PAN', 'CAFE', 'TE', 'LA', 'EL', 'UN', 'DOS', 'TRES', 'CUATRO'
                ],
                
                // Niveles 4-6: Oc√©ano (4-6 letras)
                ocean: [
                    'MAR', 'ALGA', 'CORAL', 'PECES', 'DELFIN', 'BALLENA', 'ANCLA', 'FARO', 
                    'OCEANO', 'BRISA', 'PERLA', 'BAHIA', 'PULPO', 'ANEMONA', 'SARDINA',
                    'ATUN', 'SALMON', 'LANGOSTA', 'CANGREJO', 'MEDUSA', 'TIBURON', 'ORCA',
                    'FOCA', 'PINGUINO', 'GAVIOTA', 'PELICANO', 'CORRIENTE', 'MAREA', 'PLAYA'
                ],
                
                // Niveles 7-9: Bosque (4-6 letras)
                forest: [
                    'ARBOL', 'HOJA', 'RAMA', 'PI√ëA', 'BOSQUE', 'MUSGO', 'SETAS', 'ROBLE', 
                    'CIERVO', 'ZORRO', 'NIDO', 'TREBOL', 'LIANA', 'SELVA', 'CORTEZA',
                    'PINO', 'ABETO', 'CEDRO', 'OLMO', 'SAUCE', 'ALAMO', 'CHOPO', 'CASTA√ëO',
                    'BELLOTA', 'FRUTA', 'BOSQUE', 'MADERA', 'HOJARASCA', 'SOMBRA', 'TRONCO'
                ],
                
                // Niveles 10+: Mixto m√°s dif√≠cil (7-10 letras)
                advanced: [
                    'MONTA√ëA', 'CASCADA', 'SENDERO', 'CUMBRE', 'ESTRELLA', 'GALAXIA', 
                    'PLANETA', 'COMETA', 'AVENTURA', 'MISTERIO', 'TESORO', 'LEYENDA', 
                    'TELESCOPIO', 'NEBULOSA', 'ARROYO', 'PULSAR', 'ASTEROIDE', 'METEORITO',
                    'CONSTELACION', 'EXPLORACION', 'EXPEDICION', 'DESCUBRIMIENTO', 'INVESTIGACION',
                    'LABORATORIO', 'OBSERVATORIO', 'EXPERIMENTO', 'CIENTIFICO', 'AVENTURERO'
                ]
            };
            
            // Seleccionar categor√≠a seg√∫n el nivel
            let category;
            if (level <= 3) {
                category = 'short';
            } else if (level <= 6) {
                category = 'ocean';
            } else if (level <= 9) {
                category = 'forest';
            } else {
                category = 'advanced';
            }
            
            // Seleccionar n√∫mero aleatorio de palabras (4-6) de la categor√≠a
            const bank = wordBanks[category];
            
            // Mezclar el banco de palabras para mayor aleatoriedad
            const shuffledBank = [...bank].sort(() => Math.random() - 0.5);
            
            // Filtrar palabras que no excedan 10 letras y no hayan sido usadas recientemente
            const validWords = shuffledBank.filter(word => 
                word.length <= 10 && !gameState.usedWords[category].has(word)
            );
            
            // Si no hay suficientes palabras nuevas, limpiar cache parcialmente
            if (validWords.length < 4) {
                console.log(`üîÑ Limpiando cache de categor√≠a ${category} - pocas palabras nuevas`);
                gameState.usedWords[category].clear();
                const allValidWords = shuffledBank.filter(word => word.length <= 10);
                if (allValidWords.length > 0) {
                    allValidWords.slice(0, 6).forEach(word => gameState.usedWords[category].add(word));
                    return allValidWords.slice(0, Math.min(6, allValidWords.length));
                }
            }
            
            if (validWords.length === 0) {
                console.warn(`‚ö†Ô∏è No hay palabras v√°lidas en categor√≠a ${category}`);
                return ['MAR', 'SOL', 'LUNA', 'CASA']; // Fallback
            }
            
            const numWords = Math.floor(Math.random() * 3) + 4; // 4, 5 o 6 palabras
            const selectedWords = [];
            
            // Seleccionar palabras √∫nicas del banco mezclado
            for (let i = 0; i < Math.min(numWords, validWords.length); i++) {
                selectedWords.push(validWords[i]);
                gameState.usedWords[category].add(validWords[i]); // Marcar como usada
            }
            
            console.log(`üìù Nivel ${level}: Seleccionadas ${selectedWords.length} palabras aleatorias de categor√≠a "${category}":`, selectedWords);
            console.log(`üìù Palabras disponibles en categor√≠a "${category}":`, bank.length, 'opciones');
            return selectedWords;
        }
        
        // Generar mec√°nicas aleatorias para todos los niveles
        function generateRandomMechanics(level) {
            // Las mec√°nicas siguen siendo aleatorias en todos los niveles
            
            const availableMechanics = [
                'fog',        // Niebla - revelar letras al completar palabras
                'ghost',      // Fantasma - letras transl√∫cidas
                'hiddenWords', // Palabras ocultas
                'wordTimer',   // Timer por palabra
                'dynamicTimer' // Timer din√°mico general
            ];
            
            // UNA MEC√ÅNICA POR NIVEL - No mezclar mec√°nicas
            const numMechanics = 1; // Siempre 1 mec√°nica por nivel
            
            // Seleccionar mec√°nicas aleatorias sin repetir
            const selectedMechanics = [];
            const shuffledMechanics = [...availableMechanics].sort(() => Math.random() - 0.5);
            
            for (let i = 0; i < numMechanics && i < shuffledMechanics.length; i++) {
                selectedMechanics.push(shuffledMechanics[i]);
            }
            
            console.log(`üéÆ Nivel ${level}: ${selectedMechanics.length} mec√°nicas seleccionadas:`, selectedMechanics);
            return selectedMechanics;
        }
        
        // Aplicar mec√°nicas al juego
        function applyMechanics(mechanics) {
            gameState.activeMechanics = mechanics;
            
            // Limpiar estado previo de mec√°nicas
            gameState.originalGrid = [];
            gameState.revealedCells = [];
            gameState.hiddenWords = [];
            gameState.wordTimers = {};
            gameState.levelExpired = false;
            gameState.failedAttempts = 0;
            
            // Limpiar timers
            if (gameState.dynamicTimerInterval) {
                clearInterval(gameState.dynamicTimerInterval);
                gameState.dynamicTimerInterval = null;
            }
            if (gameState.wordTimerInterval) {
                clearInterval(gameState.wordTimerInterval);
                gameState.wordTimerInterval = null;
            }
            
            // Aplicar cada mec√°nica
            mechanics.forEach(mechanic => {
                switch (mechanic) {
                    case 'fog':
                        applyFogMechanic();
                        break;
                    case 'ghost':
                        applyGhostMechanic();
                        break;
                    case 'hiddenWords':
                        applyHiddenWordsMechanic();
                        break;
                    case 'wordTimer':
                        applyWordTimerMechanic();
                        break;
                    case 'dynamicTimer':
                        applyDynamicTimerMechanic();
                        break;
                }
            });
            
            // Actualizar interfaz para mostrar mec√°nicas activas
            updateMechanicsDisplay();
            
            // Actualizar lista de palabras despu√©s de aplicar mec√°nicas
            updateWordsList();
            
            // Aplicar mec√°nicas visuales despu√©s de que se hayan aplicado las l√≥gicas
            setTimeout(() => {
                applyVisualMechanics();
            }, 200);
        }
        
        // Actualizar display de mec√°nicas activas
        function updateMechanicsDisplay() {
            const mechanicsDisplay = document.getElementById('mechanics-display');
            
            if (gameState.activeMechanics.length > 0) {
                console.log('üéÆ Mec√°nicas activas:', gameState.activeMechanics);
                
                // Mostrar el contenedor
                mechanicsDisplay.style.display = 'flex';
                
                // Limpiar contenido previo
                mechanicsDisplay.innerHTML = '';
                
                // Crear badges para cada mec√°nica
                gameState.activeMechanics.forEach(mechanic => {
                    const badge = document.createElement('div');
                    badge.className = `mechanic-badge ${mechanic}`;
                    
                    // Configurar texto y emoji seg√∫n la mec√°nica
                    switch (mechanic) {
                        case 'fog':
                            badge.textContent = 'üå´Ô∏è Niebla';
                            break;
                        case 'ghost':
                            badge.textContent = 'üëª Fantasma';
                            break;
                        case 'hiddenWords':
                            badge.textContent = 'üìù Palabras Ocultas';
                            break;
                        case 'wordTimer':
                            badge.textContent = '‚è∞ Timer por Palabra';
                            break;
                        case 'dynamicTimer':
                            badge.textContent = '‚è±Ô∏è Timer Din√°mico';
                            break;
                        default:
                            badge.textContent = `üéÆ ${mechanic}`;
                    }
                    
                    mechanicsDisplay.appendChild(badge);
                });
            } else {
                // Ocultar el contenedor si no hay mec√°nicas
                mechanicsDisplay.style.display = 'none';
            }
        }
        
        // ===== IMPLEMENTACI√ìN DE MEC√ÅNICAS =====
        
        // Aplicar mec√°nicas visuales al grid
        function applyVisualMechanics() {
            console.log('üé® Aplicando mec√°nicas visuales:', gameState.activeMechanics);
            
            // Aplicar niebla
            if (gameState.activeMechanics.includes('fog')) {
                applyFogVisual();
            }
            
            // Aplicar fantasma
            if (gameState.activeMechanics.includes('ghost')) {
                applyGhostVisual();
            }
        }
        
        // Aplicar niebla visualmente
        function applyFogVisual() {
            console.log('üå´Ô∏è Aplicando niebla visual');
            document.querySelectorAll('.grid-cell').forEach((cell) => {
                const cellIndex = parseInt(cell.dataset.index);
                if (gameState.currentGrid[cellIndex] === '?') {
                    cell.classList.add('fog');
                    cell.textContent = '?';
                    console.log(`üå´Ô∏è Celda ${cellIndex} con niebla aplicada: ${gameState.originalGrid[cellIndex]} -> ?`);
                } else {
                    // Asegurar que las celdas sin niebla no tengan la clase fog
                    cell.classList.remove('fog');
                    cell.textContent = gameState.currentGrid[cellIndex];
                }
            });
        }
        
        // Aplicar fantasma visualmente
        function applyGhostVisual() {
            console.log('üëª Aplicando fantasma visual');
            document.querySelectorAll('.grid-cell').forEach((cell) => {
                if (Math.random() < 0.25) {
                    cell.classList.add('ghost');
                    console.log(`üëª Celda con fantasma aplicado`);
                }
            });
        }
        
        // Mec√°nica de Niebla (Fog)
        function applyFogMechanic() {
            console.log('üå´Ô∏è Aplicando mec√°nica de niebla');
            console.log('üå´Ô∏è Grid actual:', gameState.currentGrid);
            console.log('üå´Ô∏è Tama√±o del grid:', gameState.currentGrid.length);
            
            // Guardar grid original antes de aplicar niebla
            gameState.originalGrid = [...gameState.currentGrid];
            
            // Aplicar niebla a algunas celdas (30% de probabilidad)
            // Las letras ocultas solo se revelan al completar palabras
            let foggedCells = 0;
            for (let i = 0; i < gameState.currentGrid.length; i++) {
                if (Math.random() < 0.3) {
                    gameState.currentGrid[i] = '?';
                    foggedCells++;
                    console.log(`üå´Ô∏è Celda ${i} oculta con niebla: ${gameState.originalGrid[i]} -> ?`);
                }
            }
            console.log(`üå´Ô∏è Total celdas con niebla: ${foggedCells}`);
        }
        
        // Mec√°nica de Fantasma (Ghost)
        function applyGhostMechanic() {
            console.log('üëª Aplicando mec√°nica de fantasma');
            
            // Aplicar clase ghost a algunas celdas (25% de probabilidad)
            setTimeout(() => {
                document.querySelectorAll('.grid-cell').forEach((cell, index) => {
                    if (Math.random() < 0.25) {
                        cell.classList.add('ghost');
                    }
                });
            }, 100);
        }
        
        // Mec√°nica de Palabras Ocultas
        function applyHiddenWordsMechanic() {
            console.log('üìù Aplicando mec√°nica de palabras ocultas');
            
            // Limpiar palabras ocultas previas
            gameState.hiddenWords = [];
            
            // Ocultar algunas palabras aleatoriamente (30% de probabilidad por palabra)
            gameState.currentWords.forEach(word => {
                if (Math.random() < 0.3) {
                    gameState.hiddenWords.push(word);
                    console.log(`üìù Palabra oculta: ${word}`);
                }
            });
            
            // Asegurar que al menos haya una palabra oculta
            if (gameState.hiddenWords.length === 0 && gameState.currentWords.length > 0) {
                const randomWord = gameState.currentWords[Math.floor(Math.random() * gameState.currentWords.length)];
                gameState.hiddenWords.push(randomWord);
                console.log(`üìù Palabra oculta forzada (m√≠nimo): ${randomWord}`);
            }
            
            console.log(`üìù Total palabras ocultas: ${gameState.hiddenWords.length}`);
        }
        
        // Mec√°nica de Timer por Palabra
        function applyWordTimerMechanic() {
            console.log('‚è∞ Aplicando mec√°nica de timer por palabra');
            
            // Ordenar palabras por longitud (m√°s dif√≠cil = m√°s larga)
            const sortedWords = [...gameState.currentWords].sort((a, b) => b.length - a.length);
            
            // Asignar tiempos diferenciados: palabra m√°s dif√≠cil 40s, las dem√°s -5s cada una
            sortedWords.forEach((word, index) => {
                const timeForWord = 40 - (index * 5); // 40s, 35s, 30s, 25s...
                gameState.wordTimers[word] = Math.max(timeForWord, 15); // M√≠nimo 15 segundos
                console.log(`‚è∞ ${word} (${word.length} letras): ${gameState.wordTimers[word]}s`);
            });
            
            // Iniciar timer
            gameState.wordTimerInterval = setInterval(() => {
                let allExpired = true;
                gameState.currentWords.forEach(word => {
                    if (gameState.wordTimers[word] > 0) {
                        gameState.wordTimers[word]--;
                        allExpired = false;
                    }
                });
                
                updateWordsList(); // Actualizar display de timers
                
                if (allExpired) {
                    clearInterval(gameState.wordTimerInterval);
                    gameState.wordTimerInterval = null;
                    console.log('‚è∞ Todos los timers de palabras expirados - NIVEL EXPIRADO');
                    gameState.levelExpired = true;
                    showMessage('‚è∞ ¬°Tiempo agotado! Nivel no completado. Usa "Limpiar Selecci√≥n" para repetir.', 'error');
                }
            }, 1000);
        }
        
        // Mec√°nica de Timer Din√°mico
        function applyDynamicTimerMechanic() {
            console.log('‚è±Ô∏è Aplicando mec√°nica de timer din√°mico');
            
            // Inicializar timer din√°mico (2 minutos)
            gameState.dynamicTimer = 120;
            
            gameState.dynamicTimerInterval = setInterval(() => {
                if (gameState.dynamicTimer > 0) {
                    gameState.dynamicTimer--;
                    updateHUD(); // Actualizar display del timer
                } else {
                    clearInterval(gameState.dynamicTimerInterval);
                    gameState.dynamicTimerInterval = null;
                    console.log('‚è±Ô∏è Timer din√°mico expirado - NIVEL EXPIRADO');
                    gameState.levelExpired = true;
                    showMessage('‚è±Ô∏è ¬°Tiempo agotado! Nivel no completado. Usa "Limpiar Selecci√≥n" para repetir.', 'error');
                }
            }, 1000);
        }
        
        // Generar grid de juego
        function generateGrid() {
            const gridContainer = document.getElementById('game-grid');
            gridContainer.innerHTML = '';
            gameState.currentGrid = [];
            
            const words = gameState.currentWords;
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            
            // Calcular el tama√±o del grid basado en la palabra m√°s larga y n√∫mero de palabras
            const maxWordLength = Math.max(...words.map(word => word.length));
            const numWords = words.length;
            
            // Grid din√°mico: m√≠nimo 8x8, m√°ximo 10x10
            // Considerar palabra m√°s larga + margen m√≠nimo
            let dynamicGridSize = Math.max(maxWordLength + 1, 8); // Palabra + 1 de margen, m√≠nimo 8
            dynamicGridSize = Math.min(dynamicGridSize, 10); // M√°ximo 10x10 para evitar problemas de espacio
            
            // Ajustar seg√∫n n√∫mero de palabras para evitar solapamientos
            if (numWords >= 5) dynamicGridSize = Math.max(dynamicGridSize, 9);
            if (numWords >= 6) dynamicGridSize = Math.max(dynamicGridSize, 10);
            
            const gridSize = dynamicGridSize;
            gameState.currentGridSize = gridSize;
            
            console.log(`üéØ Grid din√°mico: ${gridSize}x${gridSize} (palabra m√°s larga: ${maxWordLength}, palabras: ${numWords})`);
            
            
            // Actualizar CSS del grid
            gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            
            // Crear grid vac√≠o (sin letras inicialmente)
            for (let i = 0; i < gridSize * gridSize; i++) {
                gameState.currentGrid.push('');
            }
            
            // Colocar palabras din√°micamente
            placeWordsInGrid(words, gridSize);
            
            // Rellenar celdas vac√≠as con letras aleatorias
            fillEmptyCells();
            
            // Crear celdas en el DOM
            gameState.currentGrid.forEach((letter, index) => {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = letter;
                cell.dataset.index = index;
                cell.onclick = () => selectCell(index);
                
                gridContainer.appendChild(cell);
            });
            
            // Debug: Verificar que todas las palabras est√©n en el grid
            setTimeout(() => {
                debugWordPlacement();
            }, 100);
        }
        
        // Colocar palabras en el grid
        function placeWordsInGrid(words, gridSize) {
            console.log(`üéØ Iniciando colocaci√≥n de ${words.length} palabras en grid ${gridSize}x${gridSize}`);
            
            words.forEach((word, wordIndex) => {
                let placed = false;
                let attempts = 0;
                const maxAttempts = 200; // Aumentar intentos
                
                // Intentar todas las direcciones posibles para cada palabra
                const directions = [0, 1, 2, 3, 4, 5, 6, 7]; // 8 direcciones incluyendo reversa
                
                // Mejorar: intentar direcciones de forma m√°s sistem√°tica
                const shuffledDirections = [...directions].sort(() => Math.random() - 0.5);
                
                while (!placed && attempts < maxAttempts) {
                    // Usar direcci√≥n del array mezclado para mejor distribuci√≥n
                    const direction = shuffledDirections[attempts % 8];
                    
                    let startRow, startCol;
                    
                    // Determinar si usar palabra normal o reversa
                    const useReverse = direction >= 4;
                    const actualDirection = direction % 4;
                    const actualWord = useReverse ? word.split('').reverse().join('') : word;
                    
                    if (actualDirection === 0) { // Horizontal
                        startRow = Math.floor(Math.random() * gridSize);
                        startCol = Math.floor(Math.random() * (gridSize - actualWord.length + 1));
                    } else if (actualDirection === 1) { // Vertical
                        startRow = Math.floor(Math.random() * (gridSize - actualWord.length + 1));
                        startCol = Math.floor(Math.random() * gridSize);
                    } else if (actualDirection === 2) { // Diagonal izquierda (arriba-izq a abajo-der)
                        startRow = Math.floor(Math.random() * (gridSize - actualWord.length + 1));
                        startCol = Math.floor(Math.random() * (gridSize - actualWord.length + 1));
                    } else { // Diagonal derecha (arriba-der a abajo-izq)
                        startRow = Math.floor(Math.random() * (gridSize - actualWord.length + 1));
                        startCol = Math.floor(Math.random() * (gridSize - actualWord.length + 1)) + actualWord.length - 1;
                    }
                    
                    // Verificar que la palabra quepa en la direcci√≥n seleccionada
                    let fitsInDirection = true;
                    if (actualDirection === 0) { // Horizontal
                        fitsInDirection = (startCol + actualWord.length - 1) < gridSize;
                    } else if (actualDirection === 1) { // Vertical
                        fitsInDirection = (startRow + actualWord.length - 1) < gridSize;
                    } else if (actualDirection === 2) { // Diagonal izquierda
                        fitsInDirection = (startRow + actualWord.length - 1) < gridSize && (startCol + actualWord.length - 1) < gridSize;
                    } else { // Diagonal derecha
                        fitsInDirection = (startRow + actualWord.length - 1) < gridSize && (startCol - actualWord.length + 1) >= 0;
                    }
                    
                    if (!fitsInDirection) {
                        attempts++;
                        continue;
                    }
                    
                    // Verificar si se puede colocar la palabra
                    let canPlace = true;
                    const positions = [];
                    
                    for (let i = 0; i < actualWord.length; i++) {
                        let row, col;
                        
                        if (actualDirection === 0) { // Horizontal
                            row = startRow;
                            col = startCol + i;
                        } else if (actualDirection === 1) { // Vertical
                            row = startRow + i;
                            col = startCol;
                        } else if (actualDirection === 2) { // Diagonal izquierda
                            row = startRow + i;
                            col = startCol + i;
                        } else { // Diagonal derecha
                            row = startRow + i;
                            col = startCol - i;
                        }
                        
                        const index = row * gridSize + col;
                        positions.push(index);
                        
                        // Verificar conflictos (solo si ya hay una letra diferente)
                        const currentLetter = gameState.currentGrid[index];
                        // Si la celda ya tiene una letra de una palabra anterior, verificar compatibilidad
                        if (currentLetter && currentLetter !== actualWord[i]) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (canPlace) {
                        // Colocar la palabra
                        positions.forEach((index, i) => {
                            gameState.currentGrid[index] = actualWord[i];
                        });
                        placed = true;
                        const directionNames = ['horizontal', 'vertical', 'diagonal-izq', 'diagonal-der'];
                        console.log(`üìù Palabra "${word}" colocada ${useReverse ? '(REVERSA)' : ''} en direcci√≥n ${directionNames[actualDirection]} en posici√≥n (${startRow},${startCol})`);
                        console.log(`   Palabra real colocada: "${actualWord}"`);
                    }
                    
                    attempts++;
                }
                
                // Si no se pudo colocar, intentar estrategias alternativas
                if (!placed) {
                    console.log(`‚ö†Ô∏è Palabra "${word}" no se pudo colocar despu√©s de ${attempts} intentos`);
                    
                    // Estrategia 1: Intentar con posiciones m√°s espec√≠ficas
                    const specificPositions = [
                        {row: 0, col: 0, dir: 0}, // Esquina superior izquierda, horizontal
                        {row: 0, col: 0, dir: 1}, // Esquina superior izquierda, vertical
                        {row: 1, col: 1, dir: 0}, // Posici√≥n interna, horizontal
                        {row: 1, col: 1, dir: 1}, // Posici√≥n interna, vertical
                    ];
                    
                    let specificPlaced = false;
                    for (const pos of specificPositions) {
                        if (tryPlaceAtSpecificPosition(word, pos.row, pos.col, pos.dir, gridSize)) {
                            specificPlaced = true;
                            console.log(`‚úÖ Palabra "${word}" colocada en posici√≥n espec√≠fica (${pos.row},${pos.col})`);
                            break;
                        }
                    }
                    
                    // Estrategia 2: Usar posici√≥n fija como √∫ltimo recurso
                    if (!specificPlaced) {
                        console.log(`üÜò Usando posici√≥n fija para "${word}"`);
                        placeWordFixed(word, wordIndex, gridSize);
                    }
                }
            });
            
            // Validaci√≥n final: verificar que todas las palabras se colocaron
            console.log(`üéØ Colocaci√≥n completada. Verificando ${words.length} palabras...`);
            let placedCount = 0;
            words.forEach(word => {
                if (isWordInGrid(word, gridSize)) {
                    placedCount++;
                } else {
                    console.error(`‚ùå ERROR: Palabra "${word}" NO est√° en el grid despu√©s de la colocaci√≥n`);
                }
            });
            
            if (placedCount === words.length) {
                console.log(`‚úÖ Todas las ${placedCount} palabras colocadas correctamente`);
            } else {
                console.error(`‚ö†Ô∏è Solo ${placedCount}/${words.length} palabras colocadas. Hay un problema en el algoritmo.`);
            }
        }
        
        // Funci√≥n para verificar si una palabra est√° en el grid
        function isWordInGrid(word, gridSize) {
            const directions = [
                {dr: 0, dc: 1},   // Horizontal
                {dr: 1, dc: 0},   // Vertical
                {dr: 1, dc: 1},   // Diagonal derecha
                {dr: 1, dc: -1}   // Diagonal izquierda
            ];
            
            for (let row = 0; row < gridSize; row++) {
                for (let col = 0; col < gridSize; col++) {
                    for (const dir of directions) {
                        let currentWord = '';
                        let valid = true;
                        
                        for (let i = 0; i < word.length; i++) {
                            const checkRow = row + (dir.dr * i);
                            const checkCol = col + (dir.dc * i);
                            
                            if (checkRow >= 0 && checkRow < gridSize && checkCol >= 0 && checkCol < gridSize) {
                                const index = checkRow * gridSize + checkCol;
                                currentWord += gameState.currentGrid[index];
                            } else {
                                valid = false;
                                break;
                            }
                        }
                        
                        if (valid && (currentWord === word || currentWord === word.split('').reverse().join(''))) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }
        
        // Funci√≥n auxiliar para intentar colocar en posici√≥n espec√≠fica
        function tryPlaceAtSpecificPosition(word, startRow, startCol, direction, gridSize) {
            const actualWord = word;
            const positions = [];
            let canPlace = true;
            
            // Verificar si cabe en la direcci√≥n especificada
            for (let i = 0; i < actualWord.length; i++) {
                let row, col;
                
                switch (direction) {
                    case 0: // Horizontal
                        row = startRow;
                        col = startCol + i;
                        break;
                    case 1: // Vertical
                        row = startRow + i;
                        col = startCol;
                        break;
                    case 2: // Diagonal izquierda
                        row = startRow + i;
                        col = startCol - i;
                        break;
                    case 3: // Diagonal derecha
                        row = startRow + i;
                        col = startCol + i;
                        break;
                }
                
                // Verificar l√≠mites
                if (row < 0 || row >= gridSize || col < 0 || col >= gridSize) {
                    canPlace = false;
                    break;
                }
                
                const index = row * gridSize + col;
                positions.push(index);
                
                // Verificar si la celda est√° ocupada por otra palabra
                if (gameState.currentGrid[index] !== '' && gameState.currentGrid[index] !== actualWord[i]) {
                    canPlace = false;
                    break;
                }
            }
            
            if (canPlace) {
                // Colocar la palabra
                positions.forEach((index, i) => {
                    gameState.currentGrid[index] = actualWord[i];
                });
                return true;
            }
            
            return false;
        }
        
        // Colocar palabra en posici√≥n fija como fallback
        function placeWordFixed(word, wordIndex, gridSize) {
            // Solo usar posiciones fijas si la palabra no se pudo colocar
            
            // Intentar colocar en diferentes posiciones fijas
            // Ahora el grid es del tama√±o correcto, todas las posiciones son v√°lidas
            const fixedPositions = [
                { row: 0, col: 0, dir: 0 }, // Horizontal primera fila
                { row: 1, col: 0, dir: 1 }, // Vertical primera columna
                { row: 2, col: 0, dir: 0 }, // Horizontal tercera fila
                { row: 0, col: 2, dir: 1 }, // Vertical tercera columna
                { row: 3, col: 0, dir: 0 }, // Horizontal cuarta fila
                { row: 0, col: 4, dir: 1 }, // Vertical quinta columna
                { row: 4, col: 0, dir: 0 }, // Horizontal quinta fila
                { row: 0, col: 6, dir: 1 }, // Vertical s√©ptima columna
                { row: 0, col: 0, dir: 2 }, // Diagonal izquierda
                { row: 0, col: gridSize-1, dir: 3 } // Diagonal derecha
            ];
            
            let placed = false;
            for (let posIndex = 0; posIndex < fixedPositions.length && !placed; posIndex++) {
                const pos = fixedPositions[posIndex];
                let canPlace = true;
                
                // Verificar si se puede colocar en esta posici√≥n
                for (let i = 0; i < word.length; i++) {
                    const row = pos.dir === 0 ? pos.row : pos.row + i;
                    const col = pos.dir === 0 ? pos.col + i : pos.col;
                    
                    if (row >= gridSize || col >= gridSize) {
                        canPlace = false;
                        break;
                    }
                    
                    const index = row * gridSize + col;
                    const currentLetter = gameState.currentGrid[index];
                    if (currentLetter && currentLetter !== word[i]) {
                        canPlace = false;
                        break;
                    }
                }
                
                if (canPlace) {
                    // Colocar la palabra
                    for (let i = 0; i < word.length; i++) {
                        const row = pos.dir === 0 ? pos.row : pos.row + i;
                        const col = pos.dir === 0 ? pos.col + i : pos.col;
                        const index = row * gridSize + col;
                        gameState.currentGrid[index] = word[i];
                    }
                    placed = true;
                }
            }
            
        }
        
        // Rellenar celdas vac√≠as con letras aleatorias
        function fillEmptyCells() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            
            for (let i = 0; i < gameState.currentGrid.length; i++) {
                if (!gameState.currentGrid[i] || gameState.currentGrid[i] === '') {
                    gameState.currentGrid[i] = letters[Math.floor(Math.random() * letters.length)];
                }
            }
        }
        
        // Seleccionar celda
        function selectCell(index) {
            const cell = document.querySelector(`[data-index="${index}"]`);
            
            // NO permitir seleccionar si el nivel ha expirado
            if (gameState.levelExpired) {
                showMessage('‚è∞ Nivel expirado. Usa "Limpiar Selecci√≥n" para repetir.', 'error');
                return;
            }
            
            // NO revelar letras individuales con click - solo al completar palabras
            
            if (gameState.selectedCells.includes(index)) {
                // Ignorar clicks en celdas ya seleccionadas
                return;
            } else {
                // Si es la primera celda, seleccionar directamente
                if (gameState.selectedCells.length === 0) {
                    gameState.selectedCells.push(index);
                    // Animaci√≥n sutil al seleccionar
                    cell.style.transform = 'scale(1.1)';
                    setTimeout(() => {
                        cell.style.transform = '';
                    }, 150);
                } else {
                    // Verificar si es una selecci√≥n v√°lida (l√≠nea recta)
                    const newSelection = [...gameState.selectedCells, index];
                    if (isValidSelection(newSelection)) {
                        // Seleccionar
                        gameState.selectedCells.push(index);
                        // Animaci√≥n sutil al a√±adir a selecci√≥n
                        cell.style.transform = 'scale(1.05)';
                        setTimeout(() => {
                            cell.style.transform = '';
                        }, 150);
                    } else {
                        // Si no es v√°lida, empezar nueva selecci√≥n
                        gameState.selectedCells = [index];
                        // Animaci√≥n sutil al empezar nueva selecci√≥n
                        cell.style.transform = 'scale(1.1)';
                        setTimeout(() => {
                            cell.style.transform = '';
                        }, 150);
                    }
                }
            }
            
            updateCellSelection();
            
            // Solo verificar palabras si tenemos al menos 2 celdas seleccionadas
            // Y solo si la selecci√≥n es v√°lida (l√≠nea recta)
            if (gameState.selectedCells.length >= 2 && isValidSelection(gameState.selectedCells)) {
            checkForWord();
            }
        }
        
        // Verificar si la selecci√≥n temporal forma una l√≠nea recta
        function isValidSelection(cells) {
            if (cells.length < 2) return true;
            
            const gridSize = Math.sqrt(gameState.currentGrid.length);
            const cellPositions = cells.map(index => ({
                index,
                row: Math.floor(index / gridSize),
                col: index % gridSize
            }));
            
            // Ordenar por posici√≥n
            cellPositions.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });
            
            const first = cellPositions[0];
            const last = cellPositions[cellPositions.length - 1];
            
            // Calcular diferencias
            const deltaRow = last.row - first.row;
            const deltaCol = last.col - first.col;
            
            // Verificar si es horizontal (deltaRow = 0)
            if (deltaRow === 0) {
                return cellPositions.every((cell, i) => 
                    cell.row === first.row && 
                    cell.col === first.col + i
                );
            }
            
            // Verificar si es vertical (deltaCol = 0)
            if (deltaCol === 0) {
                return cellPositions.every((cell, i) => 
                    cell.col === first.col && 
                    cell.row === first.row + i
                );
            }
            
            // Verificar si es diagonal
            if (Math.abs(deltaRow) === Math.abs(deltaCol)) {
                const stepRow = deltaRow > 0 ? 1 : -1;
                const stepCol = deltaCol > 0 ? 1 : -1;
                
                return cellPositions.every((cell, i) => 
                    cell.row === first.row + (i * stepRow) && 
                    cell.col === first.col + (i * stepCol)
                );
            }
            
            return false;
        }
        
        
        // Validar que las celdas seleccionadas est√©n en l√≠nea recta
        function isValidWordSelection() {
            if (gameState.selectedCells.length < 2) return true;
            
            const gridSize = Math.sqrt(gameState.currentGrid.length);
            const cells = gameState.selectedCells.map(index => ({
                index,
                row: Math.floor(index / gridSize),
                col: index % gridSize
            }));
            
            // Ordenar celdas por posici√≥n
            cells.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });
            
            // Verificar si est√°n en l√≠nea recta
            const first = cells[0];
            const last = cells[cells.length - 1];
            
            // Calcular diferencias
            const deltaRow = last.row - first.row;
            const deltaCol = last.col - first.col;
            
            // Verificar si es horizontal (deltaRow = 0)
            if (deltaRow === 0) {
                return cells.every((cell, i) => 
                    cell.row === first.row && 
                    cell.col === first.col + i
                );
            }
            
            // Verificar si es vertical (deltaCol = 0)
            if (deltaCol === 0) {
                return cells.every((cell, i) => 
                    cell.col === first.col && 
                    cell.row === first.row + i
                );
            }
            
            // Verificar si es diagonal
            if (Math.abs(deltaRow) === Math.abs(deltaCol)) {
                const stepRow = deltaRow > 0 ? 1 : -1;
                const stepCol = deltaCol > 0 ? 1 : -1;
                
                return cells.every((cell, i) => 
                    cell.row === first.row + (i * stepRow) && 
                    cell.col === first.col + (i * stepCol)
                );
            }
            
            return false;
        }
        
        // Verificar autom√°ticamente si se form√≥ una palabra
        function checkForWord() {
            if (gameState.selectedCells.length < 2) return;
            
            // NO permitir encontrar palabras si el nivel ha expirado
            if (gameState.levelExpired) {
                showMessage('‚è∞ Nivel expirado. No se pueden encontrar m√°s palabras.', 'error');
                return;
            }
            
            // Ya verificamos que es l√≠nea recta antes de llamar esta funci√≥n
            console.log('üîç Verificando palabra con celdas:', gameState.selectedCells);
            
            // Crear palabra temporal para verificaci√≥n (usando letras reales del grid original)
            const selectedWord = gameState.selectedCells
                .map(index => {
                    // Si la celda tiene niebla, usar la letra original para verificaci√≥n
                    if (gameState.currentGrid[index] === '?') {
                        return gameState.originalGrid[index];
                    }
                    return gameState.currentGrid[index];
                })
                .join('');
            
            const reverseWord = selectedWord.split('').reverse().join('');
            
            console.log(`üîç Palabra formada: "${selectedWord}" (reversa: "${reverseWord}")`);
            console.log(`üîç Celdas seleccionadas:`, gameState.selectedCells.map(i => `${i}(${gameState.currentGrid[i]})`).join(' '));
            
            // Verificar si la palabra est√° en la lista
            const foundWord = gameState.currentWords.find(word => 
                word === selectedWord || word === reverseWord
            );
            
            if (foundWord && !gameState.foundWords.includes(foundWord)) {
                // Verificar si la palabra expir√≥ - BLOQUEAR si expir√≥
                let isExpired = false;
                if (gameState.activeMechanics.includes('wordTimer') && gameState.wordTimers[foundWord] === 0) {
                    isExpired = true;
                    console.log(`‚è∞ Palabra "${foundWord}" expirada - BLOQUEANDO completaci√≥n`);
                    showMessage(`‚è∞ La palabra "${foundWord}" ha expirado. No se puede completar.`, 'error');
                    // NO procesar la palabra si expir√≥
                    return;
                }
                
                // Palabra encontrada - revelar todas las celdas con niebla de la palabra
                gameState.foundWords.push(foundWord);
                
                // Calcular puntuaci√≥n (reducida si expir√≥)
                let scoreMultiplier = gameState.streak + 1;
                if (isExpired) {
                    scoreMultiplier = Math.max(1, Math.floor(scoreMultiplier / 2)); // Reducir puntos si expir√≥
                }
                
                gameState.score += foundWord.length * 100 * scoreMultiplier;
                gameState.streak++;
                
                // Animaciones
                const scoreElement = document.getElementById('score');
                const coinsElement = document.getElementById('coins');
                if (scoreElement) {
                    animateScore(scoreElement, foundWord.length * 100 * scoreMultiplier);
                }
                if (coinsElement) {
                    // No animar monedas por palabra individual
                }
                animateWordFound(foundWord);
                playSound('word'); // Sonido al encontrar palabra
                
                // Revelar celdas con niebla si hay mec√°nica activa
                if (gameState.activeMechanics.includes('fog')) {
                gameState.selectedCells.forEach(index => {
                        if (gameState.currentGrid[index] === '?') {
                            gameState.currentGrid[index] = gameState.originalGrid[index];
                            gameState.revealedCells.push(index);
                            
                            // Actualizar visualizaci√≥n
                            const cell = document.querySelector(`[data-index="${index}"]`);
                            if (cell) {
                                cell.textContent = gameState.originalGrid[index];
                                cell.classList.remove('fog');
                            }
                        }
                    });
                }
                
                // Marcar celdas como encontradas con animaci√≥n
                const foundCells = gameState.selectedCells.slice(); // Copia para usar en animaci√≥n
                foundCells.forEach((index, i) => {
                    const cell = document.querySelector(`[data-index="${index}"]`);
                    cell.classList.add('found');
                    // Animaci√≥n escalonada para cada celda
                    setTimeout(() => {
                        cell.style.transform = 'scale(1.2)';
                        cell.style.backgroundColor = '#10b981';
                        setTimeout(() => {
                            cell.style.transform = '';
                        }, 200);
                    }, i * 100);
                });
                
                // Mostrar mensaje (diferente si expir√≥)
                if (isExpired) {
                    showMessage(`¬°Encontraste "${foundWord}"! (Tiempo expirado) +${foundWord.length * 100 * scoreMultiplier} puntos`, 'success');
                } else {
                    showMessage(`¬°Encontraste "${foundWord}"! +${foundWord.length * 100 * scoreMultiplier} puntos`, 'success');
                }
                
                // Limpiar selecci√≥n
                gameState.selectedCells = [];
                updateCellSelection();
                updateHUD();
                updateWordsList();
                
                // Verificar si se complet√≥ el nivel
                if (gameState.foundWords.length === gameState.currentWords.length) {
                    console.log('üéØ Nivel completado! Palabras encontradas:', gameState.foundWords.length, 'de', gameState.currentWords.length);
                    setTimeout(async () => {
                        // Mostrar mensaje animado de nivel completado
                        showLevelComplete();
                        
                        // Reproducir sonido de nivel completado
                        playSound('level');
                        
                        // Animar monedas inmediatamente (antes del overlay)
                        const coinsElement = document.getElementById('coins');
                        if (coinsElement) {
                            animateCoins(coinsElement, 10);
                        }
                        
                        // Esperar a que termine la animaci√≥n antes de continuar
                        setTimeout(() => {
                            console.log('üîÑ Continuando al siguiente nivel...');
                            // Actualizar estado despu√©s de la animaci√≥n
                        gameState.currentLevel++;
                        gameState.coins += 10;
                            console.log('üìä Estado actualizado - Nivel:', gameState.currentLevel, 'Monedas:', gameState.coins);
 // Resetear errores
                        gameState.foundWords = []; // Limpiar palabras encontradas
                        
                        // Guardar progreso seg√∫n tipo de usuario
                        if (gameState.currentUser && gameState.currentUser.isGuest) {
                            saveGuestProgress();
                        } else if (gameState.currentUser && !gameState.currentUser.isGuest) {
                                saveUserProgress();
                        }
                        
                        setTimeout(() => {
                            generateNextLevel();
                            }, 1000);
                        }, 4500); // Esperar a que termine la animaci√≥n del overlay (4s + 0.5s)
                    }, 1000);
                }
            } else if (gameState.selectedCells.length >= 2) {
                // Palabra no v√°lida - NO limpiar selecci√≥n autom√°ticamente
                console.log(`‚ùå Palabra no v√°lida: ${selectedWord} o ${reverseWord}`);
                console.log('üìù Palabras disponibles:', gameState.currentWords);
                // NO limpiar gameState.selectedCells - permitir que el usuario contin√∫e
            }
        }
        
        // Actualizar selecci√≥n visual
        function updateCellSelection() {
            console.log('üéØ Actualizando selecci√≥n visual:', gameState.selectedCells);
            document.querySelectorAll('.grid-cell').forEach((cell, index) => {
                cell.classList.remove('selected');
                // Comparar usando el dataset.index que es el √≠ndice real
                const cellIndex = parseInt(cell.dataset.index);
                if (gameState.selectedCells.includes(cellIndex)) {
                    cell.classList.add('selected');
                    console.log(`‚úÖ Celda ${cellIndex} marcada como seleccionada`);
                }
            });
        }
        
        // Limpiar selecci√≥n
        function clearSelection() {
            console.log('üßπ Limpiando selecci√≥n...');
            gameState.selectedCells = [];
            updateCellSelection();
            
            // Si el nivel hab√≠a expirado, reiniciarlo con penalizaci√≥n
            if (gameState.levelExpired) {
                console.log('üîÑ Reiniciando nivel expirado...');
                gameState.failedAttempts++;
                
                // Reducir puntuaci√≥n por cada intento fallido
                const penalty = gameState.failedAttempts * 100;
                gameState.score = Math.max(0, gameState.score - penalty);
                
                showMessage(`üîÑ Reiniciando nivel... Penalizaci√≥n: -${penalty} puntos (Intento ${gameState.failedAttempts})`, 'error');
                
                // Reiniciar el nivel
                setTimeout(() => {
                    generateNextLevel(); // Esto aplicar√° las mec√°nicas de nuevo
                }, 1500);
            } else {
                console.log('üßπ Selecci√≥n limpiada correctamente');
            }
        }
        
        // Confirmar selecci√≥n
        function submitSelection() {
            if (gameState.selectedCells.length < 2) {
                showMessage('Selecciona al menos 2 letras', 'error');
                return;
            }
            
            const selectedWord = gameState.selectedCells
                .map(index => gameState.currentGrid[index])
                .join('');
            
            const reverseWord = selectedWord.split('').reverse().join('');
            
            // Verificar si la palabra est√° en la lista
            const foundWord = gameState.currentWords.find(word => 
                word === selectedWord || word === reverseWord
            );
            
            if (foundWord && !gameState.foundWords.includes(foundWord)) {
                // Palabra encontrada
                gameState.foundWords.push(foundWord);
                gameState.score += foundWord.length * 100 * (gameState.streak + 1);
                gameState.streak++;
                
                // Marcar celdas como encontradas con animaci√≥n
                const foundCells = gameState.selectedCells.slice(); // Copia para usar en animaci√≥n
                foundCells.forEach((index, i) => {
                    const cell = document.querySelector(`[data-index="${index}"]`);
                    cell.classList.add('found');
                    // Animaci√≥n escalonada para cada celda
                    setTimeout(() => {
                        cell.style.transform = 'scale(1.2)';
                        cell.style.backgroundColor = '#10b981';
                        setTimeout(() => {
                            cell.style.transform = '';
                        }, 200);
                    }, i * 100);
                });
                
                showMessage(`¬°Encontraste "${foundWord}"! +${foundWord.length * 100} puntos`, 'success');
                playSound('word'); // Sonido al encontrar palabra
                
                // Verificar si se complet√≥ el nivel
                if (gameState.foundWords.length === gameState.currentWords.length) {
                    setTimeout(() => {
                        // Mostrar mensaje animado de nivel completado
                        showLevelComplete();
                        
                        // Reproducir sonido de nivel completado
                        playSound('level');
                        
                        // Animar monedas inmediatamente (antes del overlay)
                        const coinsElement = document.getElementById('coins');
                        if (coinsElement) {
                            animateCoins(coinsElement, 10);
                        }
                        
                        // Esperar a que termine la animaci√≥n antes de continuar
                        setTimeout(() => {
                            // Actualizar estado despu√©s de la animaci√≥n
                        gameState.currentLevel++;
                        gameState.coins += 10;
                        setTimeout(() => {
                            initGame();
                            }, 1000);
                        }, 4500); // Esperar a que termine la animaci√≥n del overlay
                    }, 1000);
                }
            } else {
                // Palabra incorrecta
                gameState.streak = 0;
                showMessage(`"${selectedWord}" no es v√°lida.`, 'error');
            }
            
            clearSelection();
            updateHUD();
            updateWordsList();
        }
        
        // Actualizar informaci√≥n del usuario
        function updateUserInfo() {
            const userIcon = document.getElementById('user-icon');
            const userName = document.getElementById('user-name');
            const userStatus = document.getElementById('user-status');
            const clearProgressBtn = document.getElementById('clear-progress-btn');
            const logoutBtn = document.getElementById('logout-btn');
            const backMenuBtn = document.getElementById('back-menu-btn');
            
            if (gameState.currentUser) {
                if (gameState.currentUser.isGuest) {
                    // Usuario invitado
                    userIcon.textContent = 'üë§';
                    userName.textContent = 'Invitado';
                    userStatus.textContent = 'Invitado';
                    userStatus.className = 'user-status-guest';
                    
                    // Mostrar bot√≥n de reiniciar progreso y volver al men√∫, ocultar logout
                    if (clearProgressBtn) clearProgressBtn.style.display = 'inline-flex';
                    if (logoutBtn) logoutBtn.style.display = 'none';
                    if (backMenuBtn) backMenuBtn.style.display = 'inline-flex';
                } else {
                    // Usuario registrado
                    userIcon.textContent = 'üëë';
                    userName.textContent = gameState.currentUser.nombre || 'Usuario';
                    userStatus.textContent = 'Registrado';
                    userStatus.className = 'user-status-logged';
                    
                    // Ocultar bot√≥n de reiniciar progreso y volver al men√∫, mostrar logout
                    if (clearProgressBtn) clearProgressBtn.style.display = 'none';
                    if (logoutBtn) logoutBtn.style.display = 'inline-flex';
                    if (backMenuBtn) backMenuBtn.style.display = 'none';
                }
            } else {
                // Sin usuario (fallback)
                userIcon.textContent = '‚ùì';
                userName.textContent = 'Desconocido';
                userStatus.textContent = 'Sin sesi√≥n';
                userStatus.className = 'user-status-guest';
                
                // Ocultar botones de progreso y logout, mostrar volver al men√∫
                if (clearProgressBtn) clearProgressBtn.style.display = 'none';
                if (logoutBtn) logoutBtn.style.display = 'none';
                if (backMenuBtn) backMenuBtn.style.display = 'inline-flex';
            }
        }
        
        // Actualizar HUD
        function updateHUD() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('streak').textContent = gameState.streak;
            document.getElementById('coins').textContent = gameState.coins;
            document.getElementById('level').textContent = gameState.currentLevel;
            
            // Mostrar/ocultar timer din√°mico
            const dynamicTimerDisplay = document.getElementById('dynamic-timer-display');
            const dynamicTimer = document.getElementById('dynamic-timer');
            
            if (gameState.activeMechanics.includes('dynamicTimer') && gameState.dynamicTimer !== null) {
                dynamicTimerDisplay.style.display = 'flex';
                dynamicTimer.textContent = gameState.dynamicTimer;
            } else {
                dynamicTimerDisplay.style.display = 'none';
            }
        }
        
        // Actualizar lista de palabras
        function updateWordsList() {
            const container = document.getElementById('words-list');
            container.innerHTML = '';
            
            gameState.currentWords.forEach(word => {
                const wordElement = document.createElement('div');
                wordElement.className = 'word-item';
                
                // Verificar si la palabra est√° encontrada
                if (gameState.foundWords.includes(word)) {
                    wordElement.classList.add('found');
                }
                
                // Verificar si la palabra est√° oculta
                if (gameState.activeMechanics.includes('hiddenWords') && gameState.hiddenWords.includes(word)) {
                    wordElement.classList.add('hidden');
                    wordElement.textContent = '???';
                    console.log(`üìù Palabra oculta en lista: ${word} -> ???`);
                } else {
                wordElement.textContent = word;
                }
                
                // Agregar timer si est√° activo
                if (gameState.activeMechanics.includes('wordTimer') && gameState.wordTimers[word] !== undefined) {
                    const timer = gameState.wordTimers[word];
                    if (timer > 0) {
                        const timerElement = document.createElement('span');
                        timerElement.className = 'word-timer';
                        timerElement.textContent = `${timer}s`;
                        wordElement.appendChild(timerElement);
                    } else {
                        wordElement.classList.add('expired');
                        // Si el nivel ha expirado, mostrar todas las palabras como expiradas
                        if (gameState.levelExpired) {
                            wordElement.textContent = word + ' (EXPIRADO)';
                        }
                    }
                }
                
                container.appendChild(wordElement);
            });
        }
        
        // Inicializar aplicaci√≥n
        document.addEventListener('DOMContentLoaded', function() {

            // Prevenir zoom en m√≥viles
            document.addEventListener('gesturestart', function (e) {
                e.preventDefault();
            });
            
            // Manejar orientaci√≥n
            window.addEventListener('orientationchange', function() {
                setTimeout(() => {
                    window.scrollTo(0, 0);
                }, 100);
            });
        });
    </script>
</body>
</html>