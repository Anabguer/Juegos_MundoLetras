<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üß™ Test Mec√°nicas - Mundo Letras</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .control-group h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #6c757d;
        }

        .control-group select, .control-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            font-size: 16px;
            margin-bottom: 10px;
        }

        .control-group button {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .control-group button:hover {
            transform: translateY(-2px);
        }

        .game-area {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .game-grid {
            display: grid;
            gap: 2px;
            background: #dee2e6;
            padding: 10px;
            border-radius: 10px;
            margin: 0 auto;
            max-width: 500px;
        }

        .grid-cell {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            color: #495057;
            cursor: pointer;
            transition: all 0.3s ease;
            min-height: 50px;
            min-width: 50px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .grid-cell:hover {
            background: #e3f2fd;
            transform: scale(1.05);
        }

        .grid-cell.selected {
            background: #4facfe;
            color: white;
            transform: scale(1.1);
        }

        .grid-cell.found {
            background: #28a745;
            color: white;
        }

        .grid-cell.fog {
            background: #6c757d;
            color: #6c757d;
        }

        .grid-cell.ghost {
            animation: ghost 0.5s infinite alternate;
        }

        .grid-cell.changing {
            animation: changing 2s infinite;
        }

        .grid-cell.moving {
            animation: moving 3s infinite;
        }

        .grid-cell.disappearing {
            animation: disappearing 2s infinite;
        }

        @keyframes ghost {
            0% { opacity: 1; }
            100% { opacity: 0.3; }
        }

        @keyframes changing {
            0%, 50% { background: #ffc107; color: #212529; }
            51%, 100% { background: #17a2b8; color: white; }
        }

        @keyframes moving {
            0%, 33% { transform: translateX(0); }
            34%, 66% { transform: translateX(5px); }
            67%, 100% { transform: translateX(0); }
        }

        @keyframes disappearing {
            0%, 70% { opacity: 1; }
            71%, 100% { opacity: 0.1; }
        }

        .game-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .info-card {
            background: white;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #4facfe;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .info-card h4 {
            color: #495057;
            margin-bottom: 8px;
        }

        .info-card .value {
            font-size: 1.5em;
            font-weight: bold;
            color: #4facfe;
        }

        .words-list {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .words-list h3 {
            color: #495057;
            margin-bottom: 15px;
        }

        .word-item {
            display: inline-block;
            background: #e9ecef;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 20px;
            font-weight: 600;
            color: #495057;
        }

        .word-item.found {
            background: #28a745;
            color: white;
        }

        .word-item.hidden {
            background: #6c757d;
            color: #6c757d;
        }

        .word-timer {
            display: inline-block;
            background: #ffc107;
            color: #212529;
            padding: 4px 8px;
            border-radius: 10px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .word-timer.warning {
            background: #dc3545;
            color: white;
        }

        .mechanics-info {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }

        .mechanics-info h3 {
            color: #1976d2;
            margin-bottom: 15px;
        }

        .mechanic-item {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 8px;
            border-left: 4px solid #1976d2;
        }

        .mechanic-item h4 {
            color: #1976d2;
            margin-bottom: 5px;
        }

        .mechanic-item p {
            color: #666;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üß™ Test Mec√°nicas</h1>
            <p>Prueba todas las mec√°nicas del juego Mundo Letras</p>
        </div>

        <div class="content">
            <div class="controls">
                <div class="control-group">
                    <h3>üéÆ Configuraci√≥n del Juego</h3>
                    <label for="gridSize">Tama√±o del Grid:</label>
                    <select id="gridSize">
                        <option value="6">6x6</option>
                        <option value="7">7x7</option>
                        <option value="8">8x8</option>
                        <option value="9">9x9</option>
                        <option value="10">10x10</option>
                    </select>
                    
                    <label for="wordCount">N√∫mero de Palabras:</label>
                    <input type="number" id="wordCount" value="5" min="3" max="10">
                    
                    <button onclick="generateGame()">üéØ Generar Juego</button>
                </div>

                <div class="control-group">
                    <h3>üîß Mec√°nicas Activas</h3>
                    <label>
                        <input type="checkbox" id="fog" onchange="toggleMechanic('fog')"> 
                        üå´Ô∏è Niebla (celdas opacas hasta tocar)
                    </label>
                    <label>
                        <input type="checkbox" id="ghost" onchange="toggleMechanic('ghost')"> 
                        üëª Fantasma (parpadeo intermitente)
                    </label>
                    <label>
                        <input type="checkbox" id="hiddenWords" onchange="toggleMechanic('hiddenWords')"> 
                        üîç Palabras ocultas
                    </label>
                    <label>
                        <input type="checkbox" id="wordTimer" onchange="toggleMechanic('wordTimer')"> 
                        ‚è±Ô∏è Timer por palabra
                    </label>
                    <label>
                        <input type="checkbox" id="dynamicTimer" onchange="toggleMechanic('dynamicTimer')"> 
                        ‚ö° Timer din√°mico
                    </label>
                </div>

                <div class="control-group">
                    <h3>üéØ Acciones</h3>
                    <button onclick="clearSelection()">üßπ Limpiar Selecci√≥n</button>
                    <button onclick="startNewSelection()">üéØ Nueva Selecci√≥n</button>
                    <button onclick="resetGame()">üîÑ Reiniciar Juego</button>
                    <button onclick="activateAllMechanics()">‚ö° Activar Todas las Mec√°nicas</button>
                    <button onclick="deactivateAllMechanics()">üö´ Desactivar Todas las Mec√°nicas</button>
                    <button onclick="testMechanics()">üß™ Test R√°pido Mec√°nicas</button>
                    <button onclick="showWordsInGrid()">üîç Mostrar Palabras en Grid</button>
                    <button onclick="showAllWords()">üëÅÔ∏è Mostrar Todas las Palabras</button>
                    <button onclick="hideAllWords()">üôà Ocultar Todas las Palabras</button>
                </div>
            </div>

            <div class="game-area">
                <div class="game-grid" id="gameGrid"></div>
                
                <div class="game-info">
                    <div class="info-card">
                        <h4>‚è±Ô∏è Tiempo</h4>
                        <div class="value" id="timeDisplay">‚àû</div>
                    </div>
                    <div class="info-card">
                        <h4>üéØ Puntos</h4>
                        <div class="value" id="scoreDisplay">0</div>
                    </div>
                    <div class="info-card">
                        <h4>üî• Racha</h4>
                        <div class="value" id="streakDisplay">0</div>
                    </div>
                    <div class="info-card">
                        <h4>‚ùå Errores</h4>
                        <div class="value" id="errorsDisplay">0</div>
                    </div>
                </div>

                <div class="words-list">
                    <h3>üìù Palabras a Encontrar</h3>
                    <div id="wordsList"></div>
                </div>
            </div>

            <div class="mechanics-info">
                <h3>üìö Informaci√≥n de Mec√°nicas</h3>
                
                <div class="mechanic-item">
                    <h4>üå´Ô∏è Niebla</h4>
                    <p>Las celdas aparecen opacas hasta que las tocas. Una vez tocadas, se revelan permanentemente.</p>
                </div>
                
                <div class="mechanic-item">
                    <h4>üëª Fantasma</h4>
                    <p>Algunas celdas parpadean intermitentemente, ocultando y mostrando las letras.</p>
                </div>
                
                <div class="mechanic-item">
                    <h4>üîÑ Letras que Cambian</h4>
                    <p>Las letras rotan entre 2-3 opciones diferentes cada pocos segundos.</p>
                </div>
                
                <div class="mechanic-item">
                    <h4>üéØ Celdas que se Mueven</h4>
                    <p>Las celdas se mueven ligeramente de posici√≥n de forma continua.</p>
                </div>
                
                <div class="mechanic-item">
                    <h4>üëª Celdas que Desaparecen</h4>
                    <p>Las celdas se vuelven casi invisibles temporalmente.</p>
                </div>
                
                <div class="mechanic-item">
                    <h4>üîç Palabras Ocultas</h4>
                    <p>Algunas palabras solo se revelan despu√©s de completar otras.</p>
                </div>
                
                <div class="mechanic-item">
                    <h4>‚è±Ô∏è Timer por Palabra</h4>
                    <p>Cada palabra tiene su propio temporizador. Si se agota, la palabra se oculta.</p>
                </div>
                
                <div class="mechanic-item">
                    <h4>‚ö° Timer Din√°mico</h4>
                    <p>El tiempo aumenta con aciertos (+5s) y disminuye con errores (-3s).</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Estado del juego
        let gameState = {
            grid: [],
            originalGrid: [], // Grid original sin niebla
            words: [],
            foundWords: [],
            selectedCells: [],
            score: 0,
            streak: 0,
            errors: 0,
            time: null,
            mechanics: {
                fog: false,
                ghost: false,
                hiddenWords: false,
                wordTimer: false,
                dynamicTimer: false
            },
            wordTimers: {},
            hiddenWords: [],
            revealedCells: [], // Celdas reveladas de la niebla
            dynamicTimerInterval: null,
            wordTimerInterval: null
        };

        // Palabras de ejemplo por tema
        const wordSets = {
            ocean: ['ALGA', 'CORAL', 'DELFIN', 'MEDUSA', 'ANCLA', 'MAREAS', 'PERLA', 'NARVAL', 'BAHIA', 'ORILLA', 'BRISA', 'OCEANO', 'MAR', 'ARENAL', 'FARO', 'VELA', 'ANEMONA', 'CANGREJO', 'PULPO', 'BALLENA'],
            forest: ['ARBOL', 'HOJA', 'MUSGO', 'RAMA', 'PI√ëA', 'ROBLE', 'PINO', 'SETAS', 'ZORRO', 'CIERVO', 'NIDO', 'TRONCO', 'ARROYO', 'NIEBLA', 'SELVA', 'BOSQUE', 'LADRONERA', 'BAYA', 'LIANA', 'TREBOL'],
            space: ['ESTRELLA', 'PLANETA', 'GALAXIA', 'ASTEROIDE', 'COMETA', 'NEBULOSA', 'SATELLITE', 'COSMONAUTA', 'TELESCOPIO', 'UNIVERSO', 'ORBIT', 'METEORITO', 'CONSTELACION', 'AGUJERO', 'NEGRO', 'QUASAR', 'PULSAR', 'SUPERNOVA', 'ECLIPSE', 'AURORA']
        };

        // Generar juego
        function generateGame() {
            console.log('üéÆ Generando nuevo juego...');
            console.trace('üìç Llamada a generateGame desde:');
            
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const wordCount = parseInt(document.getElementById('wordCount').value);
            
            // Limpiar estado
            gameState.grid = [];
            gameState.originalGrid = [];
            gameState.words = [];
            gameState.foundWords = [];
            gameState.selectedCells = [];
            gameState.score = 0;
            gameState.streak = 0;
            gameState.errors = 0;
            gameState.time = null;
            gameState.wordTimers = {};
            gameState.hiddenWords = [];
            gameState.revealedCells = [];
            
            // Solo limpiar timers si se est√° reiniciando completamente el juego
            // (no cuando se cambian mec√°nicas)
            if (gameState.grid.length === 0) {
                if (gameState.dynamicTimerInterval) {
                    console.log('üßπ Limpiando timer din√°mico en reinicio');
                    clearInterval(gameState.dynamicTimerInterval);
                    gameState.dynamicTimerInterval = null;
                }
                if (gameState.wordTimerInterval) {
                    console.log('üßπ Limpiando timer de palabras en reinicio');
                    clearInterval(gameState.wordTimerInterval);
                    gameState.wordTimerInterval = null;
                }
            }
            
            // Generar grid vac√≠o
            for (let i = 0; i < gridSize * gridSize; i++) {
                gameState.grid.push('');
            }
            
            // Seleccionar palabras aleatorias
            const allWords = [...wordSets.ocean, ...wordSets.forest, ...wordSets.space];
            const selectedWords = [];
            for (let i = 0; i < wordCount; i++) {
                const randomWord = allWords[Math.floor(Math.random() * allWords.length)];
                if (!selectedWords.includes(randomWord)) {
                    selectedWords.push(randomWord);
                }
            }
            gameState.words = selectedWords;
            
            // Colocar palabras en el grid
            placeWordsInGrid(selectedWords, gridSize);
            
            // Rellenar celdas vac√≠as
            fillEmptyCells();
            
            // Aplicar mec√°nicas
            applyMechanics();
            
            // Renderizar
            renderGrid();
            renderWordsList();
            updateHUD();
            
            // Reiniciar timers activos despu√©s de generar el juego
            if (gameState.mechanics.dynamicTimer) {
                console.log('üîÑ Reiniciando timer din√°mico despu√©s de generar juego');
                startDynamicTimer();
            }
            if (gameState.mechanics.wordTimer) {
                console.log('üîÑ Reiniciando timer de palabras despu√©s de generar juego');
                startWordTimers();
            }
        }

        // Colocar palabras en el grid
        function placeWordsInGrid(words, gridSize) {
            words.forEach((word, wordIndex) => {
                let placed = false;
                let attempts = 0;
                
                while (!placed && attempts < 50) {
                    const direction = Math.floor(Math.random() * 4); // 0=H, 1=V, 2=D1, 3=D2
                    let startRow, startCol;
                    
                    if (direction === 0) { // Horizontal
                        startRow = Math.floor(Math.random() * gridSize);
                        startCol = Math.floor(Math.random() * (gridSize - word.length + 1));
                    } else if (direction === 1) { // Vertical
                        startRow = Math.floor(Math.random() * (gridSize - word.length + 1));
                        startCol = Math.floor(Math.random() * gridSize);
                    } else if (direction === 2) { // Diagonal 1
                        startRow = Math.floor(Math.random() * (gridSize - word.length + 1));
                        startCol = Math.floor(Math.random() * (gridSize - word.length + 1));
                    } else { // Diagonal 2
                        startRow = Math.floor(Math.random() * (gridSize - word.length + 1));
                        startCol = Math.floor(Math.random() * (gridSize - word.length + 1)) + word.length - 1;
                    }
                    
                    // Verificar si se puede colocar
                    let canPlace = true;
                    const positions = [];
                    
                    for (let i = 0; i < word.length; i++) {
                        let row, col;
                        if (direction === 0) {
                            row = startRow;
                            col = startCol + i;
                        } else if (direction === 1) {
                            row = startRow + i;
                            col = startCol;
                        } else if (direction === 2) {
                            row = startRow + i;
                            col = startCol + i;
                        } else {
                            row = startRow + i;
                            col = startCol - i;
                        }
                        
                        const index = row * gridSize + col;
                        positions.push(index);
                        
                        if (gameState.grid[index] && gameState.grid[index] !== word[i]) {
                            canPlace = false;
                            break;
                        }
                    }
                    
                    if (canPlace) {
                        positions.forEach((index, i) => {
                            gameState.grid[index] = word[i];
                        });
                        placed = true;
                    }
                    
                    attempts++;
                }
            });
        }

        // Rellenar celdas vac√≠as
        function fillEmptyCells() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let i = 0; i < gameState.grid.length; i++) {
                if (!gameState.grid[i]) {
                    gameState.grid[i] = letters[Math.floor(Math.random() * letters.length)];
                }
            }
        }

        // Aplicar mec√°nicas
        function applyMechanics() {
            const gridSize = Math.sqrt(gameState.grid.length);
            
            // Guardar grid original antes de aplicar mec√°nicas
            gameState.originalGrid = [...gameState.grid];
            
            // Niebla
            if (gameState.mechanics.fog) {
                for (let i = 0; i < gameState.grid.length; i++) {
                    if (Math.random() < 0.3) { // 30% de celdas con niebla
                        gameState.grid[i] = '?';
                    }
                }
            }
            
            // Palabras ocultas
            if (gameState.mechanics.hiddenWords) {
                const hiddenCount = Math.floor(gameState.words.length / 2);
                for (let i = 0; i < hiddenCount; i++) {
                    const randomWord = gameState.words[Math.floor(Math.random() * gameState.words.length)];
                    if (!gameState.hiddenWords.includes(randomWord)) {
                        gameState.hiddenWords.push(randomWord);
                    }
                }
            }
            
            // Los timers se configurar√°n manualmente cuando se activen
        }

        // Renderizar grid
        function renderGrid() {
            const gridContainer = document.getElementById('gameGrid');
            const gridSize = Math.sqrt(gameState.grid.length);
            
            gridContainer.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;
            gridContainer.innerHTML = '';
            
            gameState.grid.forEach((letter, index) => {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = letter;
                cell.dataset.index = index;
                
                // Eventos de click simples
                cell.onclick = (e) => {
                    selectCell(index);
                };
                
                // Eventos de touch simples
                cell.ontouchstart = (e) => {
                    selectCell(index);
                };
                
                // Aplicar clases de mec√°nicas
                if (gameState.mechanics.fog && letter === '?') {
                    cell.classList.add('fog');
                }
                if (gameState.mechanics.ghost && Math.random() < 0.3) {
                    cell.classList.add('ghost');
                    cell.style.animation = 'ghost 0.5s infinite alternate';
                }
                
                gridContainer.appendChild(cell);
            });
            
            // Eventos globales removidos para evitar conflictos
        }

        // Sistema de arrastre simplificado - solo click/touch

        // Renderizar lista de palabras
        function renderWordsList() {
            const wordsList = document.getElementById('wordsList');
            wordsList.innerHTML = '';
            
            gameState.words.forEach(word => {
                const wordItem = document.createElement('div');
                wordItem.className = 'word-item';
                wordItem.textContent = word;
                
                if (gameState.foundWords.includes(word)) {
                    wordItem.classList.add('found');
                } else if (gameState.hiddenWords.includes(word)) {
                    wordItem.classList.add('hidden');
                }
                
                // Timer por palabra
                if (gameState.mechanics.wordTimer && gameState.wordTimers[word]) {
                    const timer = document.createElement('span');
                    timer.className = 'word-timer';
                    timer.textContent = gameState.wordTimers[word];
                    if (gameState.wordTimers[word] < 10) {
                        timer.classList.add('warning');
                    }
                    wordItem.appendChild(timer);
                }
                
                wordsList.appendChild(wordItem);
            });
        }

        // Seleccionar celda
        function selectCell(index) {
            console.log('üñ±Ô∏è Click en celda:', index, 'Letra:', gameState.grid[index]);
            console.log('‚è∞ Timer activo:', !!gameState.dynamicTimerInterval);
            console.log('üìä Celdas seleccionadas antes:', gameState.selectedCells);
            
            // Si ya est√° seleccionada, ignorar completamente
            if (gameState.selectedCells.includes(index)) {
                console.log('‚ÑπÔ∏è Celda ya seleccionada, ignorando');
                return;
            }
            
            // Agregar nueva celda a la selecci√≥n
            if (gameState.selectedCells.length === 0) {
                // Primera celda
                gameState.selectedCells.push(index);
                console.log('‚úÖ Primera celda seleccionada');
            } else {
                // Verificar si forma l√≠nea recta
                if (isValidSelection([...gameState.selectedCells, index])) {
                    gameState.selectedCells.push(index);
                    console.log('‚úÖ Celda a√±adida a la selecci√≥n');
                    
                    // Verificar inmediatamente si formamos una palabra
                    checkForWord();
                } else {
                    // Empezar nueva selecci√≥n
                    gameState.selectedCells = [index];
                    console.log('üîÑ Nueva selecci√≥n iniciada (l√≠nea no recta)');
                }
            }
            
            console.log('üìä Celdas seleccionadas despu√©s:', gameState.selectedCells);
            updateCellSelection();
        }

        // Verificar si la selecci√≥n forma una l√≠nea recta
        function isValidSelection(cells) {
            if (cells.length < 2) return true;
            
            const gridSize = Math.sqrt(gameState.grid.length);
            const cellPositions = cells.map(index => ({
                index,
                row: Math.floor(index / gridSize),
                col: index % gridSize
            }));
            
            // Ordenar por posici√≥n
            cellPositions.sort((a, b) => {
                if (a.row !== b.row) return a.row - b.row;
                return a.col - b.col;
            });
            
            const first = cellPositions[0];
            const last = cellPositions[cellPositions.length - 1];
            
            // Calcular diferencias
            const deltaRow = last.row - first.row;
            const deltaCol = last.col - first.col;
            
            console.log('üîç Verificando l√≠nea recta:', {
                first: first,
                last: last,
                deltaRow: deltaRow,
                deltaCol: deltaCol,
                positions: cellPositions
            });
            
            // Verificar si es horizontal (deltaRow = 0)
            if (deltaRow === 0) {
                const isValid = cellPositions.every((cell, i) => 
                    cell.row === first.row && 
                    cell.col === first.col + i
                );
                console.log('üìè Horizontal:', isValid);
                return isValid;
            }
            
            // Verificar si es vertical (deltaCol = 0)
            if (deltaCol === 0) {
                const isValid = cellPositions.every((cell, i) => 
                    cell.col === first.col && 
                    cell.row === first.row + i
                );
                console.log('üìè Vertical:', isValid);
                return isValid;
            }
            
            // Verificar si es diagonal
            if (Math.abs(deltaRow) === Math.abs(deltaCol)) {
                const stepRow = deltaRow > 0 ? 1 : -1;
                const stepCol = deltaCol > 0 ? 1 : -1;
                
                const isValid = cellPositions.every((cell, i) => 
                    cell.row === first.row + (i * stepRow) && 
                    cell.col === first.col + (i * stepCol)
                );
                console.log('üìè Diagonal:', isValid);
                return isValid;
            }
            
            console.log('‚ùå No es l√≠nea recta v√°lida');
            return false;
        }

        // Actualizar selecci√≥n visual
        function updateCellSelection() {
            console.log('Actualizando selecci√≥n visual:', gameState.selectedCells);
            document.querySelectorAll('.grid-cell').forEach((cell, index) => {
                if (gameState.selectedCells.includes(index)) {
                    cell.classList.add('selected');
                    console.log('Celda', index, 'marcada como seleccionada');
                } else {
                    cell.classList.remove('selected');
                }
            });
        }

        // Verificar si se form√≥ una palabra
        function checkForWord() {
            if (gameState.selectedCells.length < 2) return;
            
            // Crear palabra temporal para verificaci√≥n (usando letras reales del grid original)
            const selectedWord = gameState.selectedCells
                .map(index => {
                    // Si la celda tiene niebla, usar la letra original para verificaci√≥n
                    if (gameState.grid[index] === '?') {
                        return gameState.originalGrid[index];
                    }
                    return gameState.grid[index];
                })
                .join('');
            
            const reverseWord = selectedWord.split('').reverse().join('');
            
            console.log('üîç Verificando palabra:', selectedWord, 'o', reverseWord);
            console.log('üìù Palabras disponibles:', gameState.words);
            
            const foundWord = gameState.words.find(word => 
                word === selectedWord || word === reverseWord
            );
            
            if (foundWord && !gameState.foundWords.includes(foundWord)) {
                // Palabra encontrada - revelar todas las celdas con niebla de la palabra
                console.log('üéâ ¬°Palabra encontrada:', foundWord, '!');
                
                // Revelar celdas con niebla
                gameState.selectedCells.forEach(index => {
                    if (gameState.grid[index] === '?') {
                        gameState.grid[index] = gameState.originalGrid[index];
                        gameState.revealedCells.push(index);
                        
                        // Actualizar visualizaci√≥n
                        const cell = document.querySelector(`[data-index="${index}"]`);
                        if (cell) {
                            cell.textContent = gameState.originalGrid[index];
                            cell.classList.remove('fog');
                        }
                    }
                });
                
                gameState.foundWords.push(foundWord);
                gameState.score += foundWord.length * 100 * (gameState.streak + 1);
                gameState.streak++;
                
                // Marcar celdas como encontradas
                gameState.selectedCells.forEach(index => {
                    document.querySelector(`[data-index="${index}"]`).classList.add('found');
                });
                
                // Limpiar selecci√≥n
                gameState.selectedCells = [];
                updateCellSelection();
                updateHUD();
                renderWordsList();
                
                // Verificar si se complet√≥ el nivel
                if (gameState.foundWords.length === gameState.words.length) {
                    alert('¬°Nivel completado!');
                }
            } else {
                console.log('‚ùå Palabra no v√°lida:', selectedWord);
                // No limpiar selecci√≥n inmediatamente, permitir seguir seleccionando
            }
        }

        // Actualizar HUD
        function updateHUD() {
            document.getElementById('scoreDisplay').textContent = gameState.score;
            document.getElementById('streakDisplay').textContent = gameState.streak;
            document.getElementById('errorsDisplay').textContent = gameState.errors;
        }

        // Toggle mec√°nica
        function toggleMechanic(mechanic) {
            console.log(`üîÑ Toggle mec√°nica: ${mechanic}`);
            gameState.mechanics[mechanic] = document.getElementById(mechanic).checked;
            console.log(`Mec√°nica ${mechanic} ${gameState.mechanics[mechanic] ? 'activada' : 'desactivada'}`);
            
            // Iniciar timers solo cuando se activen manualmente
            if (gameState.mechanics[mechanic]) {
                if (mechanic === 'dynamicTimer') {
                    console.log('‚è∞ Activando timer din√°mico...');
                    startDynamicTimer();
                    console.log('‚è∞ Timer din√°mico activado');
                } else if (mechanic === 'wordTimer') {
                    startWordTimers();
                }
            } else {
                // Limpiar timers cuando se desactiven
                if (mechanic === 'dynamicTimer' && gameState.dynamicTimerInterval) {
                    clearInterval(gameState.dynamicTimerInterval);
                    gameState.dynamicTimerInterval = null;
                } else if (mechanic === 'wordTimer' && gameState.wordTimerInterval) {
                    clearInterval(gameState.wordTimerInterval);
                    gameState.wordTimerInterval = null;
                }
            }
            
            // Regenerar el grid si ya hay un juego en curso (excepto para timers)
            if (gameState.grid.length > 0 && !['dynamicTimer', 'wordTimer'].includes(mechanic)) {
                console.log('üé® Regenerando grid para mec√°nica:', mechanic);
                renderGrid();
                renderWordsList();
            } else if (gameState.grid.length > 0) {
                // Solo actualizar la lista de palabras para timers
                console.log('üìù Actualizando lista de palabras para timer');
                renderWordsList();
            }
            
            console.log(`‚úÖ Toggle mec√°nica ${mechanic} completado`);
        }

        // Limpiar selecci√≥n
        function clearSelection() {
            gameState.selectedCells = [];
            updateCellSelection();
            console.log('üßπ Selecci√≥n limpiada');
        }

        // Empezar nueva selecci√≥n
        function startNewSelection() {
            gameState.selectedCells = [];
            updateCellSelection();
            console.log('üéØ Listo para nueva selecci√≥n');
        }

        // Reiniciar juego
        function resetGame() {
            generateGame();
        }

        // Mostrar palabras en el grid (para debug)
        function showWordsInGrid() {
            console.log('üîç Mostrando palabras en el grid:');
            console.log('üìù Palabras disponibles:', gameState.words);
            console.log('üéØ Grid completo:', gameState.grid);
            
            // Mostrar posiciones de las palabras
            gameState.words.forEach(word => {
                console.log(`üî§ Buscando "${word}" en el grid...`);
                // Aqu√≠ podr√≠amos implementar la b√∫squeda de posiciones
            });
        }

        // Mostrar todas las palabras
        function showAllWords() {
            gameState.hiddenWords = [];
            renderWordsList();
        }

        // Ocultar todas las palabras
        function hideAllWords() {
            gameState.hiddenWords = [...gameState.words];
            renderWordsList();
        }

        // Iniciar timer din√°mico
        function startDynamicTimer() {
            console.log('‚è∞ Iniciando timer din√°mico');
            if (gameState.dynamicTimerInterval) {
                console.log('‚è∞ Limpiando timer anterior');
                clearInterval(gameState.dynamicTimerInterval);
            }
            
            gameState.time = 120; // 2 minutos
            gameState.dynamicTimerInterval = setInterval(() => {
                if (gameState.time > 0) {
                    gameState.time--;
                    console.log('‚è∞ Timer tick:', gameState.time);
                    // Actualizar display de forma segura sin interferir con la selecci√≥n
                    try {
                        const timeDisplay = document.getElementById('timeDisplay');
                        if (timeDisplay && timeDisplay.textContent !== gameState.time.toString()) {
                            timeDisplay.textContent = gameState.time;
                        }
                    } catch (e) {
                        console.log('Error en timer:', e);
                    }
                } else {
                    console.log('‚è∞ Timer din√°mico terminado');
                    clearInterval(gameState.dynamicTimerInterval);
                    gameState.dynamicTimerInterval = null;
                    alert('¬°Tiempo agotado!');
                }
            }, 1000);
            
            console.log('‚è∞ Timer din√°mico configurado, ID:', gameState.dynamicTimerInterval);
        }

        // Iniciar timers por palabra
        function startWordTimers() {
            if (gameState.wordTimerInterval) {
                clearInterval(gameState.wordTimerInterval);
            }
            
            gameState.words.forEach(word => {
                gameState.wordTimers[word] = 30; // 30 segundos por palabra
            });
            
            gameState.wordTimerInterval = setInterval(() => {
                let allExpired = true;
                gameState.words.forEach(word => {
                    if (gameState.wordTimers[word] > 0) {
                        gameState.wordTimers[word]--;
                        allExpired = false;
                    }
                });
                
                renderWordsList();
                
                if (allExpired) {
                    clearInterval(gameState.wordTimerInterval);
                }
            }, 1000);
        }

        // Activar todas las mec√°nicas
        function activateAllMechanics() {
            const mechanics = ['fog', 'ghost', 'hiddenWords', 'wordTimer', 'dynamicTimer'];
            mechanics.forEach(mechanic => {
                document.getElementById(mechanic).checked = true;
                gameState.mechanics[mechanic] = true;
            });
            console.log('‚úÖ Todas las mec√°nicas activadas');
            if (gameState.grid.length > 0) {
                renderGrid();
                renderWordsList();
            }
        }

        // Desactivar todas las mec√°nicas
        function deactivateAllMechanics() {
            const mechanics = ['fog', 'ghost', 'hiddenWords', 'wordTimer', 'dynamicTimer'];
            mechanics.forEach(mechanic => {
                document.getElementById(mechanic).checked = false;
                gameState.mechanics[mechanic] = false;
            });
            console.log('‚ùå Todas las mec√°nicas desactivadas');
            if (gameState.grid.length > 0) {
                renderGrid();
                renderWordsList();
            }
        }

        // Test r√°pido de mec√°nicas
        function testMechanics() {
            console.log('üß™ Iniciando test r√°pido de mec√°nicas...');
            
            // Activar mec√°nicas disponibles
            document.getElementById('ghost').checked = true;
            document.getElementById('fog').checked = true;
            
            gameState.mechanics.ghost = true;
            gameState.mechanics.fog = true;
            
            console.log('‚úÖ Mec√°nicas activadas: ghost, fog');
            
            // Regenerar grid
            if (gameState.grid.length > 0) {
                renderGrid();
                console.log('üéÆ Grid regenerado con mec√°nicas activas');
            }
        }

        // Debug: Verificar que las funciones existen
        console.log('üîß Funciones disponibles:');
        console.log('- activateAllMechanics:', typeof activateAllMechanics);
        console.log('- deactivateAllMechanics:', typeof deactivateAllMechanics);
        console.log('- toggleMechanic:', typeof toggleMechanic);
        console.log('- generateGame:', typeof generateGame);

        // Inicializar
        generateGame();
    </script>
</body>
</html>
